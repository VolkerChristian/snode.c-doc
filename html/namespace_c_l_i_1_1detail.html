<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snode.c: CLI::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">snode.c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_c_l_i_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CLI::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1element__type.html">element_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">not a pointer  <a href="struct_c_l_i_1_1detail_1_1element__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1element__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__copyablcf4068753293666f52fa2143458d7e20.html">element_type&lt; T, typename std::enable_if&lt; is_copyable_ptr&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1element__value__type.html">element_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1pair__adaptor.html">pair_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for set-like structure: This just wraps a normal container in a few utilities that do almost nothing.  <a href="struct_c_l_i_1_1detail_1_1pair__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1pair__adaptor_3_01_t_00_01conditional__t_3_01false_00_01void__t_3_01ty57376c4a6f008b828f6707df132586d8.html">pair_adaptor&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type::first_type, typename T::value_type::second_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__istreamable.html">is_istreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for input streamability.  <a href="class_c_l_i_1_1detail_1_1is__istreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for complex.  <a href="class_c_l_i_1_1detail_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container_3_01_t_00_01conditional__t_3_01false_00_01void_9711c92f16061f5742bb50eefb1b0c0c.html">is_mutable_container&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type, decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().clear()), decltype(std::declval&lt; T &gt;().insert(std::declval&lt; decltype(std::declval&lt; T &gt;().end())&gt;(), std::declval&lt; const typename T::value_type &amp; &gt;()))&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__readable__container.html">is_readable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__readable__container_3_01_t_00_01conditional__t_3_01false_00_01void1b163ef1438ddc3089d5e11b3b2b1293.html">is_readable_container&lt; T, conditional_t&lt; false, void_t&lt; decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().begin())&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper_3_01_t_00_01conditional__t_3_01false_00_01void__t_3_01type256f69b9a9ada1608beb2e1e7b0f6f4c.html">is_wrapper&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1wrapped__type.html">wrapped_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to get the underlying value type if it exists or use a default  <a href="struct_c_l_i_1_1detail_1_1wrapped__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1wrapped__type_3_01_t_00_01def_00_01typename_01std_1_1enable__if_3_01isa724b5b3d1f263241cafc27a49bae246.html">wrapped_type&lt; T, def, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="struct_c_l_i_1_1detail_1_1wrapped__type_3_01_t_00_01def_00_01typename_01std_1_1enable__if_3_01isa724b5b3d1f263241cafc27a49bae246.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="struct_c_l_i_1_1detail_1_1type__count__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_9is__tupl1d95856913595d9d18df1e9b7db10a2c.html">type_count_base&lt; T, typename std::enable_if&lt;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_9is__tupl1d95856913595d9d18df1e9b7db10a2c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__tup573c8f6a452dc2b871d7cd3189dda714.html">type_count_base&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the base tuple size  <a href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__tup573c8f6a452dc2b871d7cd3189dda714.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mut25537d1dbe2209c0fb1d9a95e46a36a7.html">type_count_base&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type count base for containers is the <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html" title="This will only trigger for actual void type.">type_count_base</a> of the individual element.  <a href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mut25537d1dbe2209c0fb1d9a95e46a36a7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of overloads to get the type size of an object.  <a href="struct_c_l_i_1_1detail_1_1subtype__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declare the <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html" title="forward declare the subtype_count_min structure">subtype_count_min</a> structure  <a href="struct_c_l_i_1_1detail_1_1subtype__count__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="struct_c_l_i_1_1detail_1_1type__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_b01f5ffbc1be4715e41384ef05a4c2a6.html">type_count&lt; T, typename std::enable_if&lt;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_b01f5ffbc1be4715e41384ef05a4c2a6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__complex_31fac009dcf70627e04f80462c5d88ca8.html">type_count&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for complex since it sometimes looks like a wrapper.  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__complex_31fac009dcf70627e04f80462c5d88ca8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mutable__cb200eb27fab347649b083951e77032e.html">type_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size of types that are wrappers,except complex and tuples(which can also be wrappers sometimes)  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mutable__cb200eb27fab347649b083951e77032e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__wrapper_39a4e337a2aa393bb8556b7ab15846b8b.html">type_count&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size of types that are wrappers,except containers complex and tuples(which can also be wrappers sometimes)  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__wrapper_39a4e337a2aa393bb8556b7ab15846b8b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_existing_file_validator.html">ExistingFileValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing file (returns error message if check fails)  <a href="class_c_l_i_1_1detail_1_1_existing_file_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_existing_directory_validator.html">ExistingDirectoryValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing directory (returns error message if check fails)  <a href="class_c_l_i_1_1detail_1_1_existing_directory_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_existing_path_validator.html">ExistingPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing path.  <a href="class_c_l_i_1_1detail_1_1_existing_path_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_nonexistent_path_validator.html">NonexistentPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an non-existing path.  <a href="class_c_l_i_1_1detail_1_1_nonexistent_path_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_i_p_v4_validator.html">IPV4Validator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the given string is a legal ipv4 address.  <a href="class_c_l_i_1_1detail_1_1_i_p_v4_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1has__find.html">has_find</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1_app_friend.html">AppFriend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is simply to allow tests access to <a class="el" href="class_c_l_i_1_1_app.html" title="Creates a command line program, with very few defaults.">App</a>'s protected functions.  <a href="struct_c_l_i_1_1detail_1_1_app_friend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af27dda5da343e609526e3dacf435b1c6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a> </td></tr>
<tr class="memdesc:af27dda5da343e609526e3dacf435b1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple empty scoped class.  <a href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">More...</a><br /></td></tr>
<tr class="separator:af27dda5da343e609526e3dacf435b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a> { <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928">nonexistent</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">file</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20">directory</a>
 }</td></tr>
<tr class="memdesc:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_c_l_i.html">CLI</a> enumeration of different file types.  <a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">More...</a><br /></td></tr>
<tr class="separator:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba10771e3ff645fe1305be4cae517573"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573">Classifier</a> { <br />
&#160;&#160;<a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6">POSITIONAL_MARK</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77">SHORT</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3">LONG</a>
, <br />
&#160;&#160;<a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda">WINDOWS_STYLE</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7">SUBCOMMAND</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00">SUBCOMMAND_TERMINATOR</a>
<br />
 }</td></tr>
<tr class="separator:aba10771e3ff645fe1305be4cae517573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string by a delim.  <a href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">More...</a><br /></td></tr>
<tr class="separator:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ab351f13ec104e2cba19ec6baf4a552f6">join</a> (const T &amp;v, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:ab351f13ec104e2cba19ec6baf4a552f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to join a string.  <a href="namespace_c_l_i_1_1detail.html#ab351f13ec104e2cba19ec6baf4a552f6">More...</a><br /></td></tr>
<tr class="separator:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8597debec6c8bc164109538253ffc623"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callable , typename  = typename std::enable_if&lt;!std::is_constructible&lt;std::string, Callable&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8597debec6c8bc164109538253ffc623"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">join</a> (const T &amp;v, Callable func, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:a8597debec6c8bc164109538253ffc623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to join a string from processed elements.  <a href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">More...</a><br /></td></tr>
<tr class="separator:a8597debec6c8bc164109538253ffc623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74b520ee1011d38fde77f907ddfea40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af74b520ee1011d38fde77f907ddfea40"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af74b520ee1011d38fde77f907ddfea40">rjoin</a> (const T &amp;v, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:af74b520ee1011d38fde77f907ddfea40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a string in reverse order.  <a href="namespace_c_l_i_1_1detail.html#af74b520ee1011d38fde77f907ddfea40">More...</a><br /></td></tr>
<tr class="separator:af74b520ee1011d38fde77f907ddfea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae078b951ab0e11b84dffe200d0049c"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#acae078b951ab0e11b84dffe200d0049c">ltrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:acae078b951ab0e11b84dffe200d0049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from left of string.  <a href="namespace_c_l_i_1_1detail.html#acae078b951ab0e11b84dffe200d0049c">More...</a><br /></td></tr>
<tr class="separator:acae078b951ab0e11b84dffe200d0049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb44de7c57bbb1384f737dc2f04265b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a> (std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a2cb44de7c57bbb1384f737dc2f04265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from left of string.  <a href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">More...</a><br /></td></tr>
<tr class="separator:a2cb44de7c57bbb1384f737dc2f04265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9338ae7c45f34f8240a31325d8d71c"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aed9338ae7c45f34f8240a31325d8d71c">rtrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:aed9338ae7c45f34f8240a31325d8d71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from right of string.  <a href="namespace_c_l_i_1_1detail.html#aed9338ae7c45f34f8240a31325d8d71c">More...</a><br /></td></tr>
<tr class="separator:aed9338ae7c45f34f8240a31325d8d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27306fb661edc7a7017a09a0e9ee7b18"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a> (std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a27306fb661edc7a7017a09a0e9ee7b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from right of string.  <a href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">More...</a><br /></td></tr>
<tr class="separator:a27306fb661edc7a7017a09a0e9ee7b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad394fad44bd6c2a82604abba63224a92"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ad394fad44bd6c2a82604abba63224a92">trim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ad394fad44bd6c2a82604abba63224a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from string.  <a href="namespace_c_l_i_1_1detail.html#ad394fad44bd6c2a82604abba63224a92">More...</a><br /></td></tr>
<tr class="separator:ad394fad44bd6c2a82604abba63224a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ffd53b391fe1eebc540f26c8825692"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a> (std::string &amp;str, const std::string filter)</td></tr>
<tr class="memdesc:a42ffd53b391fe1eebc540f26c8825692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from string.  <a href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">More...</a><br /></td></tr>
<tr class="separator:a42ffd53b391fe1eebc540f26c8825692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b00a328b3b2da564794081646c251"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a5c7b00a328b3b2da564794081646c251">trim_copy</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a5c7b00a328b3b2da564794081646c251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of the string and then trim it.  <a href="namespace_c_l_i_1_1detail.html#a5c7b00a328b3b2da564794081646c251">More...</a><br /></td></tr>
<tr class="separator:a5c7b00a328b3b2da564794081646c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242fa1bec3353c591a730efc6307f3ea"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">remove_quotes</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a242fa1bec3353c591a730efc6307f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove quotes at the front and back of a string either '"' or '\''  <a href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">More...</a><br /></td></tr>
<tr class="separator:a242fa1bec3353c591a730efc6307f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f983b056b683129ec20e53d8c6141ab"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a6f983b056b683129ec20e53d8c6141ab">fix_newlines</a> (const std::string &amp;leader, std::string input)</td></tr>
<tr class="separator:a6f983b056b683129ec20e53d8c6141ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bd3735d1104a453e5376a43140d5a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">trim_copy</a> (const std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a09bd3735d1104a453e5376a43140d5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of the string and then trim it, any filter string can be used (any char in string is filtered)  <a href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">More...</a><br /></td></tr>
<tr class="separator:a09bd3735d1104a453e5376a43140d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569874f0c04636b7f0e63f40caf6e170"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a569874f0c04636b7f0e63f40caf6e170">format_help</a> (std::ostream &amp;out, std::string name, const std::string &amp;description, std::size_t wid)</td></tr>
<tr class="memdesc:a569874f0c04636b7f0e63f40caf6e170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a two part "help" string.  <a href="namespace_c_l_i_1_1detail.html#a569874f0c04636b7f0e63f40caf6e170">More...</a><br /></td></tr>
<tr class="separator:a569874f0c04636b7f0e63f40caf6e170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af375283ee4242348cd6d3df419d7bc62"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af375283ee4242348cd6d3df419d7bc62">format_aliases</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;aliases, std::size_t wid)</td></tr>
<tr class="memdesc:af375283ee4242348cd6d3df419d7bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print subcommand aliases.  <a href="namespace_c_l_i_1_1detail.html#af375283ee4242348cd6d3df419d7bc62">More...</a><br /></td></tr>
<tr class="separator:af375283ee4242348cd6d3df419d7bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05d1129df69e88135e178137b1fd89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a05d1129df69e88135e178137b1fd89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a> (T c)</td></tr>
<tr class="separator:a3a05d1129df69e88135e178137b1fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">valid_later_char</a> (T c)</td></tr>
<tr class="memdesc:a841371d5dbb0a52f453de4cc1d00cc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify following characters of an option.  <a href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">More...</a><br /></td></tr>
<tr class="separator:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274628d24f9e3fbc719284f1db263b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">valid_name_string</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a4274628d24f9e3fbc719284f1db263b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an option/subcommand name.  <a href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">More...</a><br /></td></tr>
<tr class="separator:a4274628d24f9e3fbc719284f1db263b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f9ea4aa9649b9b3890bdcbc64b75a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac75f9ea4aa9649b9b3890bdcbc64b75a">valid_alias_name_string</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ac75f9ea4aa9649b9b3890bdcbc64b75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an app name.  <a href="namespace_c_l_i_1_1detail.html#ac75f9ea4aa9649b9b3890bdcbc64b75a">More...</a><br /></td></tr>
<tr class="separator:ac75f9ea4aa9649b9b3890bdcbc64b75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b46b96102830769cc02952392e782f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a53b46b96102830769cc02952392e782f">is_separator</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a53b46b96102830769cc02952392e782f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a string is a container segment separator (empty or "%%")  <a href="namespace_c_l_i_1_1detail.html#a53b46b96102830769cc02952392e782f">More...</a><br /></td></tr>
<tr class="separator:a53b46b96102830769cc02952392e782f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89ce22647a9f697b800d9c47b9d956f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac89ce22647a9f697b800d9c47b9d956f">isalpha</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ac89ce22647a9f697b800d9c47b9d956f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that str consists of letters only.  <a href="namespace_c_l_i_1_1detail.html#ac89ce22647a9f697b800d9c47b9d956f">More...</a><br /></td></tr>
<tr class="separator:ac89ce22647a9f697b800d9c47b9d956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83709ec148057ec53df4383645727e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">to_lower</a> (std::string str)</td></tr>
<tr class="memdesc:ae83709ec148057ec53df4383645727e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a lower case version of a string.  <a href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">More...</a><br /></td></tr>
<tr class="separator:ae83709ec148057ec53df4383645727e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5359a7a0e33366a12e15523b100f591a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">remove_underscore</a> (std::string str)</td></tr>
<tr class="memdesc:a5359a7a0e33366a12e15523b100f591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove underscores from a string  <a href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">More...</a><br /></td></tr>
<tr class="separator:a5359a7a0e33366a12e15523b100f591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b1977d7375250cc57d90723cf1554"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">find_and_replace</a> (std::string str, std::string from, std::string to)</td></tr>
<tr class="memdesc:ab39b1977d7375250cc57d90723cf1554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and replace a substring with another substring.  <a href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">More...</a><br /></td></tr>
<tr class="separator:ab39b1977d7375250cc57d90723cf1554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89da9fa11d234a8bf504d6ec85133cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ae89da9fa11d234a8bf504d6ec85133cc">has_default_flag_values</a> (const std::string &amp;flags)</td></tr>
<tr class="memdesc:ae89da9fa11d234a8bf504d6ec85133cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the flag definitions has possible false flags  <a href="namespace_c_l_i_1_1detail.html#ae89da9fa11d234a8bf504d6ec85133cc">More...</a><br /></td></tr>
<tr class="separator:ae89da9fa11d234a8bf504d6ec85133cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b9afbe8a438ab30291d35f1f24c87c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a73b9afbe8a438ab30291d35f1f24c87c">remove_default_flag_values</a> (std::string &amp;flags)</td></tr>
<tr class="separator:a73b9afbe8a438ab30291d35f1f24c87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a356b9c9cc904af2b0a918fd55e86cd9c">find_member</a> (std::string name, const std::vector&lt; std::string &gt; names, bool <a class="el" href="namespace_c_l_i.html#a0c52326d2681814c22aa1a93ce43375e">ignore_case</a>=false, bool <a class="el" href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">ignore_underscore</a>=false)</td></tr>
<tr class="memdesc:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string is a member of a list of strings and optionally ignore case or ignore underscores.  <a href="namespace_c_l_i_1_1detail.html#a356b9c9cc904af2b0a918fd55e86cd9c">More...</a><br /></td></tr>
<tr class="separator:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fbb1952b19838d8377ab714dc33e4c"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:a59fbb1952b19838d8377ab714dc33e4c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a59fbb1952b19838d8377ab714dc33e4c">find_and_modify</a> (std::string str, std::string trigger, Callable modify)</td></tr>
<tr class="separator:a59fbb1952b19838d8377ab714dc33e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6e8a6354d9645d3da614f6734573a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aad6e8a6354d9645d3da614f6734573a8">split_up</a> (std::string str, char delimiter='\0')</td></tr>
<tr class="separator:aad6e8a6354d9645d3da614f6734573a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24078bb1f5e51808a5001a47d2b40c3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac24078bb1f5e51808a5001a47d2b40c3">escape_detect</a> (std::string &amp;str, std::size_t offset)</td></tr>
<tr class="separator:ac24078bb1f5e51808a5001a47d2b40c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af694bfd321727b1a8c5d7dab22d52617"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af694bfd321727b1a8c5d7dab22d52617">add_quotes_if_needed</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:af694bfd321727b1a8c5d7dab22d52617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add quotes if the string contains spaces.  <a href="namespace_c_l_i_1_1detail.html#af694bfd321727b1a8c5d7dab22d52617">More...</a><br /></td></tr>
<tr class="separator:af694bfd321727b1a8c5d7dab22d52617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">from_stream</a> (const std::string &amp;istring, T &amp;obj)</td></tr>
<tr class="memdesc:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated operation to get a value from a stream.  <a href="namespace_c_l_i_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">More...</a><br /></td></tr>
<tr class="separator:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a> (T &amp;&amp;value) -&gt; decltype(std::forward&lt; T &gt;(value))</td></tr>
<tr class="memdesc:a0e94052d485636fc9f18c21009026577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (directly forward if this can become a string)  <a href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">More...</a><br /></td></tr>
<tr class="separator:a0e94052d485636fc9f18c21009026577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">to_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4e5965e3013bad7369e985e2f2fd42f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from the object.  <a href="namespace_c_l_i_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">More...</a><br /></td></tr>
<tr class="separator:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">to_string</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a9c070858740ce15aaecb1c5f04e21a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (streaming must be supported for that type)  <a href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">More...</a><br /></td></tr>
<tr class="separator:a9c070858740ce15aaecb1c5f04e21a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">checked_to_string</a> (T &amp;&amp;value) -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(std::forward&lt; T &gt;(value)))</td></tr>
<tr class="memdesc:a1bcb244a7701fc68da3a863b58daf615"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespace_c_l_i_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">More...</a><br /></td></tr>
<tr class="separator:a1bcb244a7701fc68da3a863b58daf615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">checked_to_string</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:ae396058c9ea28259db0c05376bf9c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespace_c_l_i_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">More...</a><br /></td></tr>
<tr class="separator:ae396058c9ea28259db0c05376bf9c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">value_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9a74f119a795b25c40db74ffa21d3c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string as a convertible value for arithmetic types  <a href="namespace_c_l_i_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">More...</a><br /></td></tr>
<tr class="separator:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">value_string</a> (const T &amp;value) -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(value))</td></tr>
<tr class="memdesc:a130e048f492ea4619246e2f4cabaf4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">for other types just use the regular to_string function  <a href="namespace_c_l_i_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">More...</a><br /></td></tr>
<tr class="separator:a130e048f492ea4619246e2f4cabaf4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I==<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a> ()</td></tr>
<tr class="memdesc:af643ce5d039d1c94f85ca05591501085"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 if the index &gt; tuple size  <a href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">More...</a><br /></td></tr>
<tr class="separator:af643ce5d039d1c94f85ca05591501085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d45f7af2004b701e37af90df4c031b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:af5d45f7af2004b701e37af90df4c031b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type <a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+<a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt; T, I+1 &gt;);} template&lt; typename T &gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt; T, 0 &gt;)};};template&lt; typename T &gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ? <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> :<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct type_count_min { static const int value{0};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename T::value_type &gt;::value};};template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I==<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return 0;} template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;);} template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size_min&lt; T, 0 &gt;)};};template&lt; typename T &gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ?((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value&lt; <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>) ? <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct expected_count { static const int value{0};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_count&lt; typename T::value_type &gt;::value};};enum class object_category :int { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80, };template&lt; typename T, typename Enable=void &gt; struct classify_object { static constexpr object_category value{object_category::other};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integral_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::unsigned_integral};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, char &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::char_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::boolean_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::floating_point};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_assignable};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::enumeration};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::complex_number};};template&lt; typename T &gt; struct uncommon_type { using type=typename std::conditional&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type;static constexpr bool value=type::value;};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;(!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value{object_category::wrapper_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::number_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integer_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::double_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value &gt;=2 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value))&gt;::type &gt; { static constexpr object_category value{object_category::tuple_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::container_value};};template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::char_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;CHAR&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::integer_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;INT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;UINT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::floating_point||classify_object&lt; T &gt;::value==object_category::number_constructible||classify_object&lt; T &gt;::value==object_category::double_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;FLOAT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::enumeration, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;ENUM&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;BOOLEAN&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::complex_number, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;COMPLEX&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp;classify_object&lt; T &gt;::value&lt;=object_category::other, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;TEXT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; std::string type_name();template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; std::string type_name();template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value==1, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;);} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt; I==<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string{};} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt;(I&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value), std::string &gt;::type tuple_name() { std::string str=std::string(type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;))+','+tuple_name&lt; T, I+1 &gt;);<a class="el" href="instrumentation_8cpp.html#ac37cec2090666222861a77657149ef94">if</a>(str.back()==',') str.pop_back();return str;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt; &gt; std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af5d45f7af2004b701e37af90df4c031b">type_name</a> ()</td></tr>
<tr class="memdesc:af5d45f7af2004b701e37af90df4c031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively generate the tuple type name.  <a href="namespace_c_l_i_1_1detail.html#af5d45f7af2004b701e37af90df4c031b">More...</a><br /></td></tr>
<tr class="separator:af5d45f7af2004b701e37af90df4c031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; </td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a397d777acde370a61fdfc1022a97508b">type_name</a> ()</td></tr>
<tr class="memdesc:a397d777acde370a61fdfc1022a97508b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type name for a type that has a value_type member  <a href="namespace_c_l_i_1_1detail.html#a397d777acde370a61fdfc1022a97508b">More...</a><br /></td></tr>
<tr class="separator:a397d777acde370a61fdfc1022a97508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">integral_conversion</a> (const std::string &amp;input, T &amp;output) noexcept</td></tr>
<tr class="memdesc:af6685ecdb07b40a316035bb4af9b02e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an unsigned integral.  <a href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">More...</a><br /></td></tr>
<tr class="separator:af6685ecdb07b40a316035bb4af9b02e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45abf683b881127298aa28b3c4e6cf5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">to_flag_value</a> (std::string val)</td></tr>
<tr class="memdesc:af45abf683b881127298aa28b3c4e6cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a flag into an integer value typically binary flags.  <a href="namespace_c_l_i_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">More...</a><br /></td></tr>
<tr class="separator:af45abf683b881127298aa28b3c4e6cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">lexical_cast</a> (const std::string &amp;input, T &amp;output)</td></tr>
<tr class="memdesc:af286727de86fce444325681379e2c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer conversion.  <a href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">More...</a><br /></td></tr>
<tr class="separator:af286727de86fce444325681379e2c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplParams" colspan="2">template&lt;typename AssignTo , typename ConvertTo , enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">lexical_assign</a> (const std::string &amp;input, AssignTo &amp;output)</td></tr>
<tr class="memdesc:ab6647281bf64bba7b07737297ae1895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value through lexical cast operations.  <a href="namespace_c_l_i_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">More...</a><br /></td></tr>
<tr class="separator:ab6647281bf64bba7b07737297ae1895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6f215bcb727ff49f126ac3e1a13e40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a1e6f215bcb727ff49f126ac3e1a13e40">split_short</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;rest)</td></tr>
<tr class="separator:a1e6f215bcb727ff49f126ac3e1a13e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de15b0ba0d12c9170d15693477808ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0de15b0ba0d12c9170d15693477808ed">split_long</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:a0de15b0ba0d12c9170d15693477808ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbd2b5b93afe2f10427dd6e32639b0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aadbd2b5b93afe2f10427dd6e32639b0c">split_windows_style</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:aadbd2b5b93afe2f10427dd6e32639b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf817a10b92907070c02b752c37aa09d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#abf817a10b92907070c02b752c37aa09d">split_names</a> (std::string current)</td></tr>
<tr class="separator:abf817a10b92907070c02b752c37aa09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a49ea386ace9f320e1ba59d7eba49b7cf">get_default_flag_values</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract default flag values either {def} or starting with a !  <a href="namespace_c_l_i_1_1detail.html#a49ea386ace9f320e1ba59d7eba49b7cf">More...</a><br /></td></tr>
<tr class="separator:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ae97bbbd9e400bd94b316dd865cb66"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a23ae97bbbd9e400bd94b316dd865cb66">get_names</a> (const std::vector&lt; std::string &gt; &amp;input)</td></tr>
<tr class="memdesc:a23ae97bbbd9e400bd94b316dd865cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of short names, one of long names, and a single name.  <a href="namespace_c_l_i_1_1detail.html#a23ae97bbbd9e400bd94b316dd865cb66">More...</a><br /></td></tr>
<tr class="separator:a23ae97bbbd9e400bd94b316dd865cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197be0b62b4d4deef0f5cac600a6b759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">check_path</a> (const char *file) noexcept</td></tr>
<tr class="memdesc:a197be0b62b4d4deef0f5cac600a6b759"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type of the path from a file name  <a href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">More...</a><br /></td></tr>
<tr class="separator:a197be0b62b4d4deef0f5cac600a6b759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">smart_deref</a> (T value) -&gt; decltype(*value)</td></tr>
<tr class="separator:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd67b783a1c4441c89f071774ac398b"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:adcd67b783a1c4441c89f071774ac398b"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference&lt; T &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">smart_deref</a> (T &amp;value)</td></tr>
<tr class="separator:adcd67b783a1c4441c89f071774ac398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f66945cfe53b556e4c311f9a88a155"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75f66945cfe53b556e4c311f9a88a155"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a75f66945cfe53b556e4c311f9a88a155">generate_set</a> (const T &amp;set)</td></tr>
<tr class="memdesc:a75f66945cfe53b556e4c311f9a88a155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a set.  <a href="namespace_c_l_i_1_1detail.html#a75f66945cfe53b556e4c311f9a88a155">More...</a><br /></td></tr>
<tr class="separator:a75f66945cfe53b556e4c311f9a88a155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320e031a5eb12297a140d2d6fc73362a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a320e031a5eb12297a140d2d6fc73362a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a320e031a5eb12297a140d2d6fc73362a">generate_map</a> (const T &amp;map, bool key_only=false)</td></tr>
<tr class="memdesc:a320e031a5eb12297a140d2d6fc73362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a map.  <a href="namespace_c_l_i_1_1detail.html#a320e031a5eb12297a140d2d6fc73362a">More...</a><br /></td></tr>
<tr class="separator:a320e031a5eb12297a140d2d6fc73362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b4a0a97c9b07110595765887647385"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V , enable_if_t&lt;!has_find&lt; T, V &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:aa4b4a0a97c9b07110595765887647385"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aa4b4a0a97c9b07110595765887647385">search</a> (const T &amp;set, const V &amp;val) -&gt; std::pair&lt; bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:aa4b4a0a97c9b07110595765887647385"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function.  <a href="namespace_c_l_i_1_1detail.html#aa4b4a0a97c9b07110595765887647385">More...</a><br /></td></tr>
<tr class="separator:aa4b4a0a97c9b07110595765887647385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb81a667288aa66a4576a06b9322092"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:abcb81a667288aa66a4576a06b9322092"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">search</a> (const T &amp;set, const V &amp;val, const std::function&lt; V(V)&gt; &amp;filter_function) -&gt; std::pair&lt; bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:abcb81a667288aa66a4576a06b9322092"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function with a filter function.  <a href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">More...</a><br /></td></tr>
<tr class="separator:abcb81a667288aa66a4576a06b9322092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96583f0b43752f7fa77a6c24dae4802"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac96583f0b43752f7fa77a6c24dae4802"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac96583f0b43752f7fa77a6c24dae4802">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ac96583f0b43752f7fa77a6c24dae4802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on signed numbers.  <a href="namespace_c_l_i_1_1detail.html#ac96583f0b43752f7fa77a6c24dae4802">More...</a><br /></td></tr>
<tr class="separator:ac96583f0b43752f7fa77a6c24dae4802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9da7d60b3b5738079257829c777c9c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9da7d60b3b5738079257829c777c9c7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ad9da7d60b3b5738079257829c777c9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on unsigned numbers.  <a href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">More...</a><br /></td></tr>
<tr class="separator:ad9da7d60b3b5738079257829c777c9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac1a57be7d4de9c0552f91b8f16d47aad">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise.  <a href="namespace_c_l_i_1_1detail.html#ac1a57be7d4de9c0552f91b8f16d47aad">More...</a><br /></td></tr>
<tr class="separator:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aaf8289908c3b0f3fa2cb597f787a06aa">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't equal infinity. Returns false otherwise.  <a href="namespace_c_l_i_1_1detail.html#aaf8289908c3b0f3fa2cb597f787a06aa">More...</a><br /></td></tr>
<tr class="separator:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c9893591d9e9d3d4c9d7282d50b9d2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a33c9893591d9e9d3d4c9d7282d50b9d2">split_program_name</a> (std::string commandline)</td></tr>
<tr class="separator:a33c9893591d9e9d3d4c9d7282d50b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa728af1274f11fb5a62069fc3c8e2118"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_integral&lt; T &gt;::value||(sizeof(T)&lt;=1U), detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:aa728af1274f11fb5a62069fc3c8e2118"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_c_l_i_1_1_option.html">Option</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aa728af1274f11fb5a62069fc3c8e2118">default_flag_modifiers</a> (<a class="el" href="class_c_l_i_1_1_option.html">Option</a> *opt)</td></tr>
<tr class="memdesc:aa728af1274f11fb5a62069fc3c8e2118"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper functions for adding in appropriate flag modifiers for add_flag  <a href="namespace_c_l_i_1_1detail.html#aa728af1274f11fb5a62069fc3c8e2118">More...</a><br /></td></tr>
<tr class="separator:aa728af1274f11fb5a62069fc3c8e2118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382165480a50710d41e421dd54079a7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a2382165480a50710d41e421dd54079a7">convert_arg_for_ini</a> (const std::string &amp;arg, char stringQuote='&quot;', char characterQuote = '\'') </td></tr>
<tr class="separator:a2382165480a50710d41e421dd54079a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b12b08c7bc02a39431b3da4f123e93d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0b12b08c7bc02a39431b3da4f123e93d">ini_join</a> (const std::vector&lt; std::string &gt; &amp;args, char sepChar=',', char arrayStart='[', char arrayEnd=']', char stringQuote='&quot;', char characterQuote = '\'') </td></tr>
<tr class="memdesc:a0b12b08c7bc02a39431b3da4f123e93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comma separated join, adds quotes if needed.  <a href="namespace_c_l_i_1_1detail.html#a0b12b08c7bc02a39431b3da4f123e93d">More...</a><br /></td></tr>
<tr class="separator:a0b12b08c7bc02a39431b3da4f123e93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d5b7ba1cbf90d9882ab35c67156469"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a36d5b7ba1cbf90d9882ab35c67156469">generate_parents</a> (const std::string &amp;section, std::string &amp;name, char parentSeparator)</td></tr>
<tr class="separator:a36d5b7ba1cbf90d9882ab35c67156469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c3c6f67c8fef09def5f328856dd154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af3c3c6f67c8fef09def5f328856dd154">checkParentSegments</a> (std::vector&lt; <a class="el" href="struct_c_l_i_1_1_config_item.html">ConfigItem</a> &gt; &amp;output, const std::string &amp;currentSection, char parentSeparator)</td></tr>
<tr class="memdesc:af3c3c6f67c8fef09def5f328856dd154"><td class="mdescLeft">&#160;</td><td class="mdescRight">assuming non default segments do a check on the close and open of the segments in a configItem structure  <a href="namespace_c_l_i_1_1detail.html#af3c3c6f67c8fef09def5f328856dd154">More...</a><br /></td></tr>
<tr class="separator:af3c3c6f67c8fef09def5f328856dd154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a99abe3824b1f1bea457ad0ae635f5c51"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> {1 &lt;&lt; 29}</td></tr>
<tr class="separator:a99abe3824b1f1bea457ad0ae635f5c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c35a876e2917ffdc1ee618e0c06619"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">dummy</a> = {}</td></tr>
<tr class="memdesc:a01c35a876e2917ffdc1ee618e0c06619"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance to use in EnableIf.  <a href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">More...</a><br /></td></tr>
<tr class="separator:a01c35a876e2917ffdc1ee618e0c06619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aba10771e3ff645fe1305be4cae517573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba10771e3ff645fe1305be4cae517573">&#9670;&nbsp;</a></span>Classifier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573">CLI::detail::Classifier</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6"></a>POSITIONAL_MARK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77"></a>SHORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3"></a>LONG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda"></a>WINDOWS_STYLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7"></a>SUBCOMMAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00"></a>SUBCOMMAND_TERMINATOR&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l05583">5583</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l05583"></a><span class="lineno"> 5583</span>&#160;{ <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693">NONE</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6">POSITIONAL_MARK</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77">SHORT</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3">LONG</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda">WINDOWS_STYLE</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7">SUBCOMMAND</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00">SUBCOMMAND_TERMINATOR</a> };</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda">CLI::detail::Classifier::WINDOWS_STYLE</a></div><div class="ttdeci">@ WINDOWS_STYLE</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6">CLI::detail::Classifier::POSITIONAL_MARK</a></div><div class="ttdeci">@ POSITIONAL_MARK</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77">CLI::detail::Classifier::SHORT</a></div><div class="ttdeci">@ SHORT</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00">CLI::detail::Classifier::SUBCOMMAND_TERMINATOR</a></div><div class="ttdeci">@ SUBCOMMAND_TERMINATOR</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693">CLI::detail::Classifier::NONE</a></div><div class="ttdeci">@ NONE</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3">CLI::detail::Classifier::LONG</a></div><div class="ttdeci">@ LONG</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7">CLI::detail::Classifier::SUBCOMMAND</a></div><div class="ttdeci">@ SUBCOMMAND</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af27dda5da343e609526e3dacf435b1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27dda5da343e609526e3dacf435b1c6">&#9670;&nbsp;</a></span>enabler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">CLI::detail::enabler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple empty scoped class. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00947">947</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;{};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a20a9a67e5f06ba0dc3f2ded2fed16f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a9a67e5f06ba0dc3f2ded2fed16f55">&#9670;&nbsp;</a></span>path_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">CLI::detail::path_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_c_l_i.html">CLI</a> enumeration of different file types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928"></a>nonexistent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac"></a>file&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20"></a>directory&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03048">3048</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;{ <a class="code" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928">nonexistent</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">file</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20">directory</a> };</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928">CLI::detail::path_type::nonexistent</a></div><div class="ttdeci">@ nonexistent</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20">CLI::detail::path_type::directory</a></div><div class="ttdeci">@ directory</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">CLI::detail::path_type::file</a></div><div class="ttdeci">@ file</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af694bfd321727b1a8c5d7dab22d52617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af694bfd321727b1a8c5d7dab22d52617">&#9670;&nbsp;</a></span>add_quotes_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::add_quotes_if_needed </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add quotes if the string contains spaces. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00558">558</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                                                               {</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;            <span class="keywordflow">if</span> ((str.front() != <span class="charliteral">&#39;&quot;&#39;</span> &amp;&amp; str.front() != <span class="charliteral">&#39;\&#39;&#39;</span>) || str.front() != str.back()) {</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                <span class="keywordtype">char</span> quote = str.find(<span class="charliteral">&#39;&quot;&#39;</span>) &lt; str.find(<span class="charliteral">&#39;\&#39;&#39;</span>) ? <span class="charliteral">&#39;\&#39;&#39;</span> : <span class="charliteral">&#39;&quot;&#39;</span>;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                <span class="keywordflow">if</span> (str.find(<span class="charliteral">&#39; &#39;</span>) != std::string::npos) {</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;                    str.insert(0, 1, quote);</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;                    str.append(1, quote);</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                }</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            }</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a197be0b62b4d4deef0f5cac600a6b759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197be0b62b4d4deef0f5cac600a6b759">&#9670;&nbsp;</a></span>check_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a> CLI::detail::check_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type of the path from a file name </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03077">3077</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;                                                               {</div>
<div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;<span class="preprocessor">#if defined(_MSC_VER)</span></div>
<div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;            <span class="keyword">struct </span>__stat64 buffer;</div>
<div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160;            <span class="keywordflow">if</span> (_stat64(file, &amp;buffer) == 0) {</div>
<div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;                <span class="keywordflow">return</span> ((buffer.st_mode &amp; S_IFDIR) != 0) ? path_type::directory : path_type::file;</div>
<div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;            }</div>
<div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;            <span class="keyword">struct </span>stat buffer;</div>
<div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;            <span class="keywordflow">if</span> (stat(file, &amp;buffer) == 0) {</div>
<div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;                <span class="keywordflow">return</span> ((buffer.st_mode &amp; S_IFDIR) != 0) ? path_type::directory : path_type::file;</div>
<div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160;            }</div>
<div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160;            <span class="keywordflow">return</span> path_type::nonexistent;</div>
<div class="line"><a name="l03090"></a><span class="lineno"> 3090</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">file</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l07652">CLI::App::_process_config_file()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03113">CLI::detail::ExistingDirectoryValidator::ExistingDirectoryValidator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03095">CLI::detail::ExistingFileValidator::ExistingFileValidator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03131">CLI::detail::ExistingPathValidator::ExistingPathValidator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03228">CLI::FileOnDefaultPath::FileOnDefaultPath()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03146">CLI::detail::NonexistentPathValidator::NonexistentPathValidator()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03925">split_program_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a197be0b62b4d4deef0f5cac600a6b759_icgraph.svg" width="655" height="460"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac1a57be7d4de9c0552f91b8f16d47aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a57be7d4de9c0552f91b8f16d47aad">&#9670;&nbsp;</a></span>checked_multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, bool&gt;::type CLI::detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03449">3449</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03449"></a><span class="lineno"> 3449</span>&#160;                                                                                            {</div>
<div class="line"><a name="l03450"></a><span class="lineno"> 3450</span>&#160;            <span class="keywordflow">if</span> (a == 0 || b == 0 || a == 1 || b == 1) {</div>
<div class="line"><a name="l03451"></a><span class="lineno"> 3451</span>&#160;                a *= b;</div>
<div class="line"><a name="l03452"></a><span class="lineno"> 3452</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l03453"></a><span class="lineno"> 3453</span>&#160;            }</div>
<div class="line"><a name="l03454"></a><span class="lineno"> 3454</span>&#160;            <span class="keywordflow">if</span> (a == (std::numeric_limits&lt;T&gt;::min)() || b == (std::numeric_limits&lt;T&gt;::min)()) {</div>
<div class="line"><a name="l03455"></a><span class="lineno"> 3455</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l03456"></a><span class="lineno"> 3456</span>&#160;            }</div>
<div class="line"><a name="l03457"></a><span class="lineno"> 3457</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">overflowCheck</a>(a, b)) {</div>
<div class="line"><a name="l03458"></a><span class="lineno"> 3458</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l03459"></a><span class="lineno"> 3459</span>&#160;            }</div>
<div class="line"><a name="l03460"></a><span class="lineno"> 3460</span>&#160;            a *= b;</div>
<div class="line"><a name="l03461"></a><span class="lineno"> 3461</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l03462"></a><span class="lineno"> 3462</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_ad9da7d60b3b5738079257829c777c9c7"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">CLI::detail::overflowCheck</a></div><div class="ttdeci">std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type overflowCheck(const T &amp;a, const T &amp;b)</div><div class="ttdoc">Do a check for overflow on unsigned numbers.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03443">CLI11.hpp:3443</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03443">overflowCheck()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08350">CLI::App::_parse_arg()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l04935">CLI::Option::get_items_expected_max()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac1a57be7d4de9c0552f91b8f16d47aad_cgraph.svg" width="399" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac1a57be7d4de9c0552f91b8f16d47aad_icgraph.svg" width="590" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaf8289908c3b0f3fa2cb597f787a06aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8289908c3b0f3fa2cb597f787a06aa">&#9670;&nbsp;</a></span>checked_multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, bool&gt;::type CLI::detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't equal infinity. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03466">3466</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03466"></a><span class="lineno"> 3466</span>&#160;                                                                                                  {</div>
<div class="line"><a name="l03467"></a><span class="lineno"> 3467</span>&#160;            T c = a * b;</div>
<div class="line"><a name="l03468"></a><span class="lineno"> 3468</span>&#160;            <span class="keywordflow">if</span> (std::isinf(c) &amp;&amp; !std::isinf(a) &amp;&amp; !std::isinf(b)) {</div>
<div class="line"><a name="l03469"></a><span class="lineno"> 3469</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l03470"></a><span class="lineno"> 3470</span>&#160;            }</div>
<div class="line"><a name="l03471"></a><span class="lineno"> 3471</span>&#160;            a = c;</div>
<div class="line"><a name="l03472"></a><span class="lineno"> 3472</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l03473"></a><span class="lineno"> 3473</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae396058c9ea28259db0c05376bf9c1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae396058c9ea28259db0c05376bf9c1de">&#9670;&nbsp;</a></span>checked_to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01285">1285</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;                                         {</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;            <span class="keywordflow">return</span> std::string{};</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bcb244a7701fc68da3a863b58daf615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcb244a7701fc68da3a863b58daf615">&#9670;&nbsp;</a></span>checked_to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(std::forward&lt;T&gt;(value))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01279">1279</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;                                                                                       {</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">to_string</a>(std::forward&lt;T&gt;(value));</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a9c070858740ce15aaecb1c5f04e21a09"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">CLI::detail::to_string</a></div><div class="ttdeci">std::string to_string(T &amp;&amp;value)</div><div class="ttdoc">Convert an object to a string (streaming must be supported for that type)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l01244">CLI11.hpp:1244</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01244">to_string()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a1bcb244a7701fc68da3a863b58daf615_cgraph.svg" width="359" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af3c3c6f67c8fef09def5f328856dd154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c3c6f67c8fef09def5f328856dd154">&#9670;&nbsp;</a></span>checkParentSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLI::detail::checkParentSegments </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_c_l_i_1_1_config_item.html">ConfigItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>currentSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>parentSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assuming non default segments do a check on the close and open of the segments in a configItem structure </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08993">8993</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08993"></a><span class="lineno"> 8993</span>&#160;                                                                                                                              {</div>
<div class="line"><a name="l08994"></a><span class="lineno"> 8994</span>&#160;            std::string estring;</div>
<div class="line"><a name="l08995"></a><span class="lineno"> 8995</span>&#160;            <span class="keyword">auto</span> parents = <a class="code" href="namespace_c_l_i_1_1detail.html#a36d5b7ba1cbf90d9882ab35c67156469">detail::generate_parents</a>(currentSection, estring, parentSeparator);</div>
<div class="line"><a name="l08996"></a><span class="lineno"> 8996</span>&#160;            <span class="keywordflow">if</span> (!output.empty() &amp;&amp; output.back().name == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><a name="l08997"></a><span class="lineno"> 8997</span>&#160;                std::size_t msize = (parents.size() &gt; 1U) ? parents.size() : 2;</div>
<div class="line"><a name="l08998"></a><span class="lineno"> 8998</span>&#160;                <span class="keywordflow">while</span> (output.back().parents.size() &gt;= msize) {</div>
<div class="line"><a name="l08999"></a><span class="lineno"> 8999</span>&#160;                    output.push_back(output.back());</div>
<div class="line"><a name="l09000"></a><span class="lineno"> 9000</span>&#160;                    output.back().parents.pop_back();</div>
<div class="line"><a name="l09001"></a><span class="lineno"> 9001</span>&#160;                }</div>
<div class="line"><a name="l09002"></a><span class="lineno"> 9002</span>&#160; </div>
<div class="line"><a name="l09003"></a><span class="lineno"> 9003</span>&#160;                <span class="keywordflow">if</span> (parents.size() &gt; 1) {</div>
<div class="line"><a name="l09004"></a><span class="lineno"> 9004</span>&#160;                    std::size_t common = 0;</div>
<div class="line"><a name="l09005"></a><span class="lineno"> 9005</span>&#160;                    std::size_t mpair = (std::min)(output.back().parents.size(), parents.size() - 1);</div>
<div class="line"><a name="l09006"></a><span class="lineno"> 9006</span>&#160;                    <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; mpair; ++ii) {</div>
<div class="line"><a name="l09007"></a><span class="lineno"> 9007</span>&#160;                        <span class="keywordflow">if</span> (output.back().parents[ii] != parents[ii]) {</div>
<div class="line"><a name="l09008"></a><span class="lineno"> 9008</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l09009"></a><span class="lineno"> 9009</span>&#160;                        }</div>
<div class="line"><a name="l09010"></a><span class="lineno"> 9010</span>&#160;                        ++common;</div>
<div class="line"><a name="l09011"></a><span class="lineno"> 9011</span>&#160;                    }</div>
<div class="line"><a name="l09012"></a><span class="lineno"> 9012</span>&#160;                    <span class="keywordflow">if</span> (common == mpair) {</div>
<div class="line"><a name="l09013"></a><span class="lineno"> 9013</span>&#160;                        output.pop_back();</div>
<div class="line"><a name="l09014"></a><span class="lineno"> 9014</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l09015"></a><span class="lineno"> 9015</span>&#160;                        <span class="keywordflow">while</span> (output.back().parents.size() &gt; common + 1) {</div>
<div class="line"><a name="l09016"></a><span class="lineno"> 9016</span>&#160;                            output.push_back(output.back());</div>
<div class="line"><a name="l09017"></a><span class="lineno"> 9017</span>&#160;                            output.back().parents.pop_back();</div>
<div class="line"><a name="l09018"></a><span class="lineno"> 9018</span>&#160;                        }</div>
<div class="line"><a name="l09019"></a><span class="lineno"> 9019</span>&#160;                    }</div>
<div class="line"><a name="l09020"></a><span class="lineno"> 9020</span>&#160;                    <span class="keywordflow">for</span> (std::size_t ii = common; ii &lt; parents.size() - 1; ++ii) {</div>
<div class="line"><a name="l09021"></a><span class="lineno"> 9021</span>&#160;                        output.emplace_back();</div>
<div class="line"><a name="l09022"></a><span class="lineno"> 9022</span>&#160;                        output.back().parents.assign(parents.begin(), parents.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(ii) + 1);</div>
<div class="line"><a name="l09023"></a><span class="lineno"> 9023</span>&#160;                        output.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><a name="l09024"></a><span class="lineno"> 9024</span>&#160;                    }</div>
<div class="line"><a name="l09025"></a><span class="lineno"> 9025</span>&#160;                }</div>
<div class="line"><a name="l09026"></a><span class="lineno"> 9026</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parents.size() &gt; 1) {</div>
<div class="line"><a name="l09027"></a><span class="lineno"> 9027</span>&#160;                <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; parents.size() - 1; ++ii) {</div>
<div class="line"><a name="l09028"></a><span class="lineno"> 9028</span>&#160;                    output.emplace_back();</div>
<div class="line"><a name="l09029"></a><span class="lineno"> 9029</span>&#160;                    output.back().parents.assign(parents.begin(), parents.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(ii) + 1);</div>
<div class="line"><a name="l09030"></a><span class="lineno"> 9030</span>&#160;                    output.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><a name="l09031"></a><span class="lineno"> 9031</span>&#160;                }</div>
<div class="line"><a name="l09032"></a><span class="lineno"> 9032</span>&#160;            }</div>
<div class="line"><a name="l09033"></a><span class="lineno"> 9033</span>&#160; </div>
<div class="line"><a name="l09034"></a><span class="lineno"> 9034</span>&#160;            <span class="comment">// insert a section end which is just an empty items_buffer</span></div>
<div class="line"><a name="l09035"></a><span class="lineno"> 9035</span>&#160;            output.emplace_back();</div>
<div class="line"><a name="l09036"></a><span class="lineno"> 9036</span>&#160;            output.back().parents = std::move(parents);</div>
<div class="line"><a name="l09037"></a><span class="lineno"> 9037</span>&#160;            output.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><a name="l09038"></a><span class="lineno"> 9038</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a36d5b7ba1cbf90d9882ab35c67156469"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a36d5b7ba1cbf90d9882ab35c67156469">CLI::detail::generate_parents</a></div><div class="ttdeci">std::vector&lt; std::string &gt; generate_parents(const std::string &amp;section, std::string &amp;name, char parentSeparator)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l08968">CLI11.hpp:8968</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l08968">generate_parents()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09041">CLI::ConfigBase::from_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af3c3c6f67c8fef09def5f328856dd154_cgraph.svg" width="586" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af3c3c6f67c8fef09def5f328856dd154_icgraph.svg" width="396" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2382165480a50710d41e421dd54079a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2382165480a50710d41e421dd54079a7">&#9670;&nbsp;</a></span>convert_arg_for_ini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::convert_arg_for_ini </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>stringQuote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>characterQuote</em> = <code>'\''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08893">8893</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08893"></a><span class="lineno"> 8893</span>&#160;                                                                                                                       {</div>
<div class="line"><a name="l08894"></a><span class="lineno"> 8894</span>&#160;            <span class="keywordflow">if</span> (arg.empty()) {</div>
<div class="line"><a name="l08895"></a><span class="lineno"> 8895</span>&#160;                <span class="keywordflow">return</span> std::string(2, stringQuote);</div>
<div class="line"><a name="l08896"></a><span class="lineno"> 8896</span>&#160;            }</div>
<div class="line"><a name="l08897"></a><span class="lineno"> 8897</span>&#160;            <span class="comment">// some specifically supported strings</span></div>
<div class="line"><a name="l08898"></a><span class="lineno"> 8898</span>&#160;            <span class="keywordflow">if</span> (arg == <span class="stringliteral">&quot;true&quot;</span> || arg == <span class="stringliteral">&quot;false&quot;</span> || arg == <span class="stringliteral">&quot;nan&quot;</span> || arg == <span class="stringliteral">&quot;inf&quot;</span>) {</div>
<div class="line"><a name="l08899"></a><span class="lineno"> 8899</span>&#160;                <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08900"></a><span class="lineno"> 8900</span>&#160;            }</div>
<div class="line"><a name="l08901"></a><span class="lineno"> 8901</span>&#160;            <span class="comment">// floating point conversion can convert some hex codes, but don&#39;t try that here</span></div>
<div class="line"><a name="l08902"></a><span class="lineno"> 8902</span>&#160;            <span class="keywordflow">if</span> (arg.compare(0, 2, <span class="stringliteral">&quot;0x&quot;</span>) != 0 &amp;&amp; arg.compare(0, 2, <span class="stringliteral">&quot;0X&quot;</span>) != 0) {</div>
<div class="line"><a name="l08903"></a><span class="lineno"> 8903</span>&#160;                <span class="keywordtype">double</span> val;</div>
<div class="line"><a name="l08904"></a><span class="lineno"> 8904</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">detail::lexical_cast</a>(arg, val)) {</div>
<div class="line"><a name="l08905"></a><span class="lineno"> 8905</span>&#160;                    <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08906"></a><span class="lineno"> 8906</span>&#160;                }</div>
<div class="line"><a name="l08907"></a><span class="lineno"> 8907</span>&#160;            }</div>
<div class="line"><a name="l08908"></a><span class="lineno"> 8908</span>&#160;            <span class="comment">// just quote a single non numeric character</span></div>
<div class="line"><a name="l08909"></a><span class="lineno"> 8909</span>&#160;            <span class="keywordflow">if</span> (arg.size() == 1) {</div>
<div class="line"><a name="l08910"></a><span class="lineno"> 8910</span>&#160;                <span class="keywordflow">return</span> std::string(1, characterQuote) + arg + characterQuote;</div>
<div class="line"><a name="l08911"></a><span class="lineno"> 8911</span>&#160;            }</div>
<div class="line"><a name="l08912"></a><span class="lineno"> 8912</span>&#160;            <span class="comment">// handle hex, binary or octal arguments</span></div>
<div class="line"><a name="l08913"></a><span class="lineno"> 8913</span>&#160;            <span class="keywordflow">if</span> (arg.front() == <span class="charliteral">&#39;0&#39;</span>) {</div>
<div class="line"><a name="l08914"></a><span class="lineno"> 8914</span>&#160;                <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;x&#39;</span>) {</div>
<div class="line"><a name="l08915"></a><span class="lineno"> 8915</span>&#160;                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><a name="l08916"></a><span class="lineno"> 8916</span>&#160;                            return (x &gt;= <span class="stringliteral">&#39;0&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;9&#39;</span>) || (x &gt;= <span class="stringliteral">&#39;A&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;F&#39;</span>) || (x &gt;= <span class="stringliteral">&#39;a&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;f&#39;</span>);</div>
<div class="line"><a name="l08917"></a><span class="lineno"> 8917</span>&#160;                        })) {</div>
<div class="line"><a name="l08918"></a><span class="lineno"> 8918</span>&#160;                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08919"></a><span class="lineno"> 8919</span>&#160;                    }</div>
<div class="line"><a name="l08920"></a><span class="lineno"> 8920</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;o&#39;</span>) {</div>
<div class="line"><a name="l08921"></a><span class="lineno"> 8921</span>&#160;                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><a name="l08922"></a><span class="lineno"> 8922</span>&#160;                            return (x &gt;= <span class="stringliteral">&#39;0&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;7&#39;</span>);</div>
<div class="line"><a name="l08923"></a><span class="lineno"> 8923</span>&#160;                        })) {</div>
<div class="line"><a name="l08924"></a><span class="lineno"> 8924</span>&#160;                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08925"></a><span class="lineno"> 8925</span>&#160;                    }</div>
<div class="line"><a name="l08926"></a><span class="lineno"> 8926</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;b&#39;</span>) {</div>
<div class="line"><a name="l08927"></a><span class="lineno"> 8927</span>&#160;                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><a name="l08928"></a><span class="lineno"> 8928</span>&#160;                            return (x == <span class="stringliteral">&#39;0&#39;</span> || x == <span class="stringliteral">&#39;1&#39;</span>);</div>
<div class="line"><a name="l08929"></a><span class="lineno"> 8929</span>&#160;                        })) {</div>
<div class="line"><a name="l08930"></a><span class="lineno"> 8930</span>&#160;                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08931"></a><span class="lineno"> 8931</span>&#160;                    }</div>
<div class="line"><a name="l08932"></a><span class="lineno"> 8932</span>&#160;                }</div>
<div class="line"><a name="l08933"></a><span class="lineno"> 8933</span>&#160;            }</div>
<div class="line"><a name="l08934"></a><span class="lineno"> 8934</span>&#160;            <span class="keywordflow">if</span> (arg.find_first_of(stringQuote) == std::string::npos) {</div>
<div class="line"><a name="l08935"></a><span class="lineno"> 8935</span>&#160;                <span class="keywordflow">return</span> std::string(1, stringQuote) + arg + stringQuote;</div>
<div class="line"><a name="l08936"></a><span class="lineno"> 8936</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l08937"></a><span class="lineno"> 8937</span>&#160;                <span class="keywordflow">return</span> characterQuote + arg + characterQuote;</div>
<div class="line"><a name="l08938"></a><span class="lineno"> 8938</span>&#160;            }</div>
<div class="line"><a name="l08939"></a><span class="lineno"> 8939</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_af286727de86fce444325681379e2c511"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">CLI::detail::lexical_cast</a></div><div class="ttdeci">bool lexical_cast(const std::string &amp;input, T &amp;output)</div><div class="ttdoc">Integer conversion.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l01854">CLI11.hpp:1854</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01854">lexical_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08942">ini_join()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l09173">CLI::ConfigBase::to_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a2382165480a50710d41e421dd54079a7_cgraph.svg" width="568" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a2382165480a50710d41e421dd54079a7_icgraph.svg" width="539" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa728af1274f11fb5a62069fc3c8e2118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa728af1274f11fb5a62069fc3c8e2118">&#9670;&nbsp;</a></span>default_flag_modifiers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!std::is_integral&lt; T &gt;::value||(sizeof(T)&lt;=1U), detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_l_i_1_1_option.html">Option</a> * CLI::detail::default_flag_modifiers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_l_i_1_1_option.html">Option</a> *&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper functions for adding in appropriate flag modifiers for add_flag </p>
<p>summing modifiers </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l05604">5604</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l05604"></a><span class="lineno"> 5604</span>&#160;                                                    {</div>
<div class="line"><a name="l05605"></a><span class="lineno"> 5605</span>&#160;            <span class="keywordflow">return</span> opt-&gt;always_capture_default();</div>
<div class="line"><a name="l05606"></a><span class="lineno"> 5606</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l04233">CLI::OptionBase&lt; CRTP &gt;::always_capture_default()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aa728af1274f11fb5a62069fc3c8e2118_cgraph.svg" width="379" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac24078bb1f5e51808a5001a47d2b40c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24078bb1f5e51808a5001a47d2b40c3">&#9670;&nbsp;</a></span>escape_detect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CLI::detail::escape_detect </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function detects an equal or colon followed by an escaped quote after an argument then modifies the string to replace the equality with a space. This is needed to allow the split up function to work properly and is intended to be used with the find_and_modify function the return value is the offset+1 which is required by the find_and_modify function. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00545">545</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                                                                         {</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            <span class="keyword">auto</span> next = str[offset + 1];</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;            <span class="keywordflow">if</span> ((next == <span class="charliteral">&#39;\&quot;&#39;</span>) || (next == <span class="charliteral">&#39;\&#39;&#39;</span>) || (next == <span class="charliteral">&#39;`&#39;</span>)) {</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                <span class="keyword">auto</span> astart = str.find_last_of(<span class="stringliteral">&quot;-/ \&quot;\&#39;`&quot;</span>, offset - 1);</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                <span class="keywordflow">if</span> (astart != std::string::npos) {</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                    <span class="keywordflow">if</span> (str[astart] == ((str[offset] == <span class="charliteral">&#39;=&#39;</span>) ? <span class="charliteral">&#39;-&#39;</span> : <span class="charliteral">&#39;/&#39;</span>))</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                        str[offset] = <span class="charliteral">&#39; &#39;</span>; <span class="comment">// interpret this as a space so the split_up works properly</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                }</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            }</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            <span class="keywordflow">return</span> offset + 1;</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06775">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac24078bb1f5e51808a5001a47d2b40c3_icgraph.svg" width="319" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a59fbb1952b19838d8377ab714dc33e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fbb1952b19838d8377ab714dc33e4c">&#9670;&nbsp;</a></span>find_and_modify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::find_and_modify </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>modify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a trigger string and call a modify callable function that takes the current string and starting position of the trigger and returns the position in the string to search for the next trigger string </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00480">480</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;            std::size_t start_pos = 0;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;            <span class="keywordflow">while</span> ((start_pos = str.find(trigger, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                start_pos = modify(str, start_pos);</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            }</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06775">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a59fbb1952b19838d8377ab714dc33e4c_icgraph.svg" width="328" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab39b1977d7375250cc57d90723cf1554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39b1977d7375250cc57d90723cf1554">&#9670;&nbsp;</a></span>find_and_replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::find_and_replace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and replace a substring with another substring. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00420">420</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                                                                                       {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;            std::size_t start_pos = 0;</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160; </div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            <span class="keywordflow">while</span> ((start_pos = str.find(from, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                str.replace(start_pos, from.length(), to);</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                start_pos += to.length();</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;            }</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160; </div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09457">CLI::Formatter::make_expanded()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03925">split_program_name()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00490">split_up()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ab39b1977d7375250cc57d90723cf1554_icgraph.svg" width="579" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a356b9c9cc904af2b0a918fd55e86cd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356b9c9cc904af2b0a918fd55e86cd9c">&#9670;&nbsp;</a></span>find_member()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t CLI::detail::find_member </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_underscore</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a string is a member of a list of strings and optionally ignore case or ignore underscores. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00450">450</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                                                                                                                                {</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;            <span class="keyword">auto</span> it = std::end(names);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i.html#a0c52326d2681814c22aa1a93ce43375e">ignore_case</a>) {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">ignore_underscore</a>) {</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                    name = <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(name));</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                    it = std::find_if(std::begin(names), std::end(names), [&amp;name](std::string local_name) {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                        <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(local_name)) == name;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                    });</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                    name = <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(name);</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                    it = std::find_if(std::begin(names), std::end(names), [&amp;name](std::string local_name) {</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                        <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(local_name) == name;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                    });</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                }</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160; </div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">ignore_underscore</a>) {</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                name = <a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(name);</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                it = std::find_if(std::begin(names), std::end(names), [&amp;name](std::string local_name) {</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(local_name) == name;</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                });</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                it = std::find(std::begin(names), std::end(names), name);</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;            }</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160; </div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;            <span class="keywordflow">return</span> (it != std::end(names)) ? (it - std::begin(names)) : (-1);</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a5359a7a0e33366a12e15523b100f591a"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">CLI::detail::remove_underscore</a></div><div class="ttdeci">std::string remove_underscore(std::string str)</div><div class="ttdoc">remove underscores from a string</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00414">CLI11.hpp:414</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_ae83709ec148057ec53df4383645727e9"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">CLI::detail::to_lower</a></div><div class="ttdeci">std::string to_lower(std::string str)</div><div class="ttdoc">Return a lower case version of a string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00406">CLI11.hpp:406</a></div></div>
<div class="ttc" id="anamespace_c_l_i_html_a0c52326d2681814c22aa1a93ce43375e"><div class="ttname"><a href="namespace_c_l_i.html#a0c52326d2681814c22aa1a93ce43375e">CLI::ignore_case</a></div><div class="ttdeci">std::string ignore_case(std::string item)</div><div class="ttdoc">Helper function to allow ignore_case to be passed to IsMember or Transform.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03706">CLI11.hpp:3706</a></div></div>
<div class="ttc" id="anamespace_c_l_i_html_a111b6f05d21b9b84e7ba933ade79884c"><div class="ttname"><a href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">CLI::ignore_underscore</a></div><div class="ttdeci">std::string ignore_underscore(std::string item)</div><div class="ttdoc">Helper function to allow ignore_underscore to be passed to IsMember or Transform.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03711">CLI11.hpp:3711</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03706">CLI::ignore_case()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03711">CLI::ignore_underscore()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00414">remove_underscore()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00406">to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05137">CLI::Option::check_fname()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05132">CLI::Option::check_lname()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05127">CLI::Option::check_sname()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l05146">CLI::Option::get_flag_value()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a356b9c9cc904af2b0a918fd55e86cd9c_cgraph.svg" width="611" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a356b9c9cc904af2b0a918fd55e86cd9c_icgraph.svg" width="878" height="248"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6f983b056b683129ec20e53d8c6141ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f983b056b683129ec20e53d8c6141ab">&#9670;&nbsp;</a></span>fix_newlines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::fix_newlines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>leader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a leader to the beginning of all new lines (nothing is added at the start of the first line). <code>"; "</code> would be for ini files</p>
<p>Can't use Regex, or this would be a subs. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00305">305</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                                                                                {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            std::string::size_type n = 0;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            <span class="keywordflow">while</span> (n != std::string::npos &amp;&amp; n &lt; input.size()) {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                n = input.find(<span class="charliteral">&#39;\n&#39;</span>, n);</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                <span class="keywordflow">if</span> (n != std::string::npos) {</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                    input = input.substr(0, n + 1) + leader + input.substr(n + 1);</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                    n += leader.size();</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                }</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            }</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <span class="keywordflow">return</span> input;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l00341">format_aliases()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l09173">CLI::ConfigBase::to_config()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a6f983b056b683129ec20e53d8c6141ab_icgraph.svg" width="588" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af375283ee4242348cd6d3df419d7bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af375283ee4242348cd6d3df419d7bc62">&#9670;&nbsp;</a></span>format_aliases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CLI::detail::format_aliases </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>wid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print subcommand aliases. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00341">341</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                                                                                               {</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            <span class="keywordflow">if</span> (!aliases.empty()) {</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                out &lt;&lt; std::setw(static_cast&lt;int&gt;(wid)) &lt;&lt; <span class="stringliteral">&quot;     aliases: &quot;</span>;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                <span class="keywordtype">bool</span> front = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; alias : aliases) {</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                    <span class="keywordflow">if</span> (!front) {</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                        out &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                        front = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                    }</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                    out &lt;&lt; <a class="code" href="namespace_c_l_i_1_1detail.html#a6f983b056b683129ec20e53d8c6141ab">detail::fix_newlines</a>(<span class="stringliteral">&quot;              &quot;</span>, alias);</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                }</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;            }</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a6f983b056b683129ec20e53d8c6141ab"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a6f983b056b683129ec20e53d8c6141ab">CLI::detail::fix_newlines</a></div><div class="ttdeci">std::string fix_newlines(const std::string &amp;leader, std::string input)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00305">CLI11.hpp:305</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00305">fix_newlines()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09457">CLI::Formatter::make_expanded()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af375283ee4242348cd6d3df419d7bc62_cgraph.svg" width="375" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af375283ee4242348cd6d3df419d7bc62_icgraph.svg" width="356" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a569874f0c04636b7f0e63f40caf6e170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569874f0c04636b7f0e63f40caf6e170">&#9670;&nbsp;</a></span>format_help()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CLI::detail::format_help </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>wid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a two part "help" string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00323">323</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                                                                                                                     {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            name = <span class="stringliteral">&quot;  &quot;</span> + name;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            out &lt;&lt; std::setw(static_cast&lt;int&gt;(wid)) &lt;&lt; std::left &lt;&lt; name;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <span class="keywordflow">if</span> (!description.empty()) {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                <span class="keywordflow">if</span> (name.length() &gt;= wid)</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                    out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; std::setw(<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(wid)) &lt;&lt; <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> c : description) {</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                    out.put(c);</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                    <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;\n&#39;</span>) {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                        out &lt;&lt; std::setw(static_cast&lt;int&gt;(wid)) &lt;&lt; <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                    }</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                }</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            }</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l04123">CLI::Formatter::make_option()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l09451">CLI::Formatter::make_subcommand()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a569874f0c04636b7f0e63f40caf6e170_icgraph.svg" width="392" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a65d0ac7d1e313c85e8027b8e7a82d29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d0ac7d1e313c85e8027b8e7a82d29a">&#9670;&nbsp;</a></span>from_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::from_stream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>istring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated operation to get a value from a stream. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01160">1160</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;                                                           {</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;            std::istringstream is;</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;            is.str(istring);</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;            is &gt;&gt; obj;</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;            <span class="keywordflow">return</span> !is.fail() &amp;&amp; !is.rdbuf()-&gt;in_avail();</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a320e031a5eb12297a140d2d6fc73362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320e031a5eb12297a140d2d6fc73362a">&#9670;&nbsp;</a></span>generate_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::generate_map </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>key_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a map. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03359">3359</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03359"></a><span class="lineno"> 3359</span>&#160;                                                                    {</div>
<div class="line"><a name="l03360"></a><span class="lineno"> 3360</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03361"></a><span class="lineno"> 3361</span>&#160;            <span class="keyword">using</span> iteration_type_t = <span class="keyword">typename</span> detail::pair_adaptor&lt;element_t&gt;::value_type; <span class="comment">// the type of the object pair</span></div>
<div class="line"><a name="l03362"></a><span class="lineno"> 3362</span>&#160;            std::string out(1, <span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><a name="l03363"></a><span class="lineno"> 3363</span>&#160;            out.append(<a class="code" href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">detail::join</a>(</div>
<div class="line"><a name="l03364"></a><span class="lineno"> 3364</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(map),</div>
<div class="line"><a name="l03365"></a><span class="lineno"> 3365</span>&#160;                [key_only](<span class="keyword">const</span> iteration_type_t&amp; v) {</div>
<div class="line"><a name="l03366"></a><span class="lineno"> 3366</span>&#160;                    std::string res{<a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">detail::to_string</a>(detail::pair_adaptor&lt;element_t&gt;::first(v))};</div>
<div class="line"><a name="l03367"></a><span class="lineno"> 3367</span>&#160; </div>
<div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;                    <span class="keywordflow">if</span> (!key_only) {</div>
<div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160;                        res.append(<span class="stringliteral">&quot;-&gt;&quot;</span>);</div>
<div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;                        res += <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">detail::to_string</a>(detail::pair_adaptor&lt;element_t&gt;::second(v));</div>
<div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160;                    }</div>
<div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;                    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l03373"></a><span class="lineno"> 3373</span>&#160;                },</div>
<div class="line"><a name="l03374"></a><span class="lineno"> 3374</span>&#160;                <span class="stringliteral">&quot;,&quot;</span>));</div>
<div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160;            out.push_back(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a8597debec6c8bc164109538253ffc623"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">CLI::detail::join</a></div><div class="ttdeci">std::string join(const T &amp;v, Callable func, std::string delim=&quot;,&quot;)</div><div class="ttdoc">Simple function to join a string from processed elements.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00208">CLI11.hpp:208</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_adcd67b783a1c4441c89f071774ac398b"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">CLI::detail::smart_deref</a></div><div class="ttdeci">std::remove_reference&lt; T &gt;::type &amp; smart_deref(T &amp;value)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03338">CLI11.hpp:3338</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00192">join()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03332">smart_deref()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l01227">to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03641">CLI::CheckedTransformer::CheckedTransformer()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03575">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a320e031a5eb12297a140d2d6fc73362a_cgraph.svg" width="400" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a320e031a5eb12297a140d2d6fc73362a_icgraph.svg" width="464" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a36d5b7ba1cbf90d9882ab35c67156469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d5b7ba1cbf90d9882ab35c67156469">&#9670;&nbsp;</a></span>generate_parents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::generate_parents </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>parentSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08968">8968</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08968"></a><span class="lineno"> 8968</span>&#160;                                                                                                                      {</div>
<div class="line"><a name="l08969"></a><span class="lineno"> 8969</span>&#160;            std::vector&lt;std::string&gt; parents;</div>
<div class="line"><a name="l08970"></a><span class="lineno"> 8970</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(section) != <span class="stringliteral">&quot;default&quot;</span>) {</div>
<div class="line"><a name="l08971"></a><span class="lineno"> 8971</span>&#160;                <span class="keywordflow">if</span> (section.find(parentSeparator) != std::string::npos) {</div>
<div class="line"><a name="l08972"></a><span class="lineno"> 8972</span>&#160;                    parents = <a class="code" href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">detail::split</a>(section, parentSeparator);</div>
<div class="line"><a name="l08973"></a><span class="lineno"> 8973</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l08974"></a><span class="lineno"> 8974</span>&#160;                    parents = {section};</div>
<div class="line"><a name="l08975"></a><span class="lineno"> 8975</span>&#160;                }</div>
<div class="line"><a name="l08976"></a><span class="lineno"> 8976</span>&#160;            }</div>
<div class="line"><a name="l08977"></a><span class="lineno"> 8977</span>&#160;            <span class="keywordflow">if</span> (name.find(parentSeparator) != std::string::npos) {</div>
<div class="line"><a name="l08978"></a><span class="lineno"> 8978</span>&#160;                std::vector&lt;std::string&gt; plist = <a class="code" href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">detail::split</a>(name, parentSeparator);</div>
<div class="line"><a name="l08979"></a><span class="lineno"> 8979</span>&#160;                name = plist.back();</div>
<div class="line"><a name="l08980"></a><span class="lineno"> 8980</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">detail::remove_quotes</a>(name);</div>
<div class="line"><a name="l08981"></a><span class="lineno"> 8981</span>&#160;                plist.pop_back();</div>
<div class="line"><a name="l08982"></a><span class="lineno"> 8982</span>&#160;                parents.insert(parents.end(), plist.begin(), plist.end());</div>
<div class="line"><a name="l08983"></a><span class="lineno"> 8983</span>&#160;            }</div>
<div class="line"><a name="l08984"></a><span class="lineno"> 8984</span>&#160; </div>
<div class="line"><a name="l08985"></a><span class="lineno"> 8985</span>&#160;            <span class="comment">// clean up quotes on the parents</span></div>
<div class="line"><a name="l08986"></a><span class="lineno"> 8986</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; parent : parents) {</div>
<div class="line"><a name="l08987"></a><span class="lineno"> 8987</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">detail::remove_quotes</a>(parent);</div>
<div class="line"><a name="l08988"></a><span class="lineno"> 8988</span>&#160;            }</div>
<div class="line"><a name="l08989"></a><span class="lineno"> 8989</span>&#160;            <span class="keywordflow">return</span> parents;</div>
<div class="line"><a name="l08990"></a><span class="lineno"> 8990</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a242fa1bec3353c591a730efc6307f3ea"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">CLI::detail::remove_quotes</a></div><div class="ttdeci">std::string &amp; remove_quotes(std::string &amp;str)</div><div class="ttdoc">remove quotes at the front and back of a string either '&quot;' or '\''</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00291">CLI11.hpp:291</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a9e78d046d8a9c2d6f246bd1e36e57ec6"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">CLI::detail::split</a></div><div class="ttdeci">std::vector&lt; std::string &gt; split(const std::string &amp;s, char delim)</div><div class="ttdoc">Split a string by a delim.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00174">CLI11.hpp:174</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00291">remove_quotes()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00174">split()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00406">to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08993">checkParentSegments()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l09041">CLI::ConfigBase::from_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a36d5b7ba1cbf90d9882ab35c67156469_cgraph.svg" width="363" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a36d5b7ba1cbf90d9882ab35c67156469_icgraph.svg" width="598" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a75f66945cfe53b556e4c311f9a88a155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f66945cfe53b556e4c311f9a88a155">&#9670;&nbsp;</a></span>generate_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::generate_set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a set. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03343">3343</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03343"></a><span class="lineno"> 3343</span>&#160;                                             {</div>
<div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;            <span class="keyword">using</span> iteration_type_t = <span class="keyword">typename</span> detail::pair_adaptor&lt;element_t&gt;::value_type; <span class="comment">// the type of the object pair</span></div>
<div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;            std::string out(1, <span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;            out.append(<a class="code" href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">detail::join</a>(</div>
<div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(set),</div>
<div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;                [](<span class="keyword">const</span> iteration_type_t&amp; v) {</div>
<div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;                    <span class="keywordflow">return</span> detail::pair_adaptor&lt;element_t&gt;::first(v);</div>
<div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;                },</div>
<div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;                <span class="stringliteral">&quot;,&quot;</span>));</div>
<div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;            out.push_back(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"><a name="l03354"></a><span class="lineno"> 3354</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01047">CLI::detail::pair_adaptor&lt; T, _ &gt;::first()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00192">join()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03332">smart_deref()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03496">CLI::IsMember::IsMember()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a75f66945cfe53b556e4c311f9a88a155_cgraph.svg" width="416" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a75f66945cfe53b556e4c311f9a88a155_icgraph.svg" width="427" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a49ea386ace9f320e1ba59d7eba49b7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ea386ace9f320e1ba59d7eba49b7cf">&#9670;&nbsp;</a></span>get_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; CLI::detail::get_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract default flag values either {def} or starting with a ! </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02565">2565</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;                                                                                                      {</div>
<div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;            std::vector&lt;std::string&gt; flags = <a class="code" href="namespace_c_l_i_1_1detail.html#abf817a10b92907070c02b752c37aa09d">split_names</a>(str);</div>
<div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;            flags.erase(std::remove_if(</div>
<div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;                            flags.begin(),</div>
<div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;                            flags.end(),</div>
<div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;                            [](<span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;                                return ((name.empty()) ||</div>
<div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;                                        (!(((name.find_first_of(<span class="stringliteral">&#39;{&#39;</span>) != std::string::npos) &amp;&amp; (name.back() == <span class="stringliteral">&#39;}&#39;</span>)) || (name[0] == <span class="stringliteral">&#39;!&#39;</span>))));</div>
<div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;                            }),</div>
<div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;                        flags.end());</div>
<div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;            std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; output;</div>
<div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;            output.reserve(flags.size());</div>
<div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; flag : flags) {</div>
<div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;                <span class="keyword">auto</span> def_start = flag.find_first_of(<span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;                std::string defval = <span class="stringliteral">&quot;false&quot;</span>;</div>
<div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;                <span class="keywordflow">if</span> ((def_start != std::string::npos) &amp;&amp; (flag.back() == <span class="charliteral">&#39;}&#39;</span>)) {</div>
<div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;                    defval = flag.substr(def_start + 1);</div>
<div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;                    defval.pop_back();</div>
<div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;                    flag.erase(def_start, std::string::npos);</div>
<div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;                }</div>
<div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;                flag.erase(0, flag.find_first_not_of(<span class="stringliteral">&quot;-!&quot;</span>));</div>
<div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;                output.emplace_back(flag, defval);</div>
<div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;            }</div>
<div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;            <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_abf817a10b92907070c02b752c37aa09d"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#abf817a10b92907070c02b752c37aa09d">CLI::detail::split_names</a></div><div class="ttdeci">std::vector&lt; std::string &gt; split_names(std::string current)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l02553">CLI11.hpp:2553</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l02553">split_names()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06332">CLI::App::_add_flag_internal()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a49ea386ace9f320e1ba59d7eba49b7cf_cgraph.svg" width="904" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a49ea386ace9f320e1ba59d7eba49b7cf_icgraph.svg" width="375" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a23ae97bbbd9e400bd94b316dd865cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ae97bbbd9e400bd94b316dd865cb66">&#9670;&nbsp;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;std::string&gt;, std::vector&lt;std::string&gt;, std::string&gt; CLI::detail::get_names </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of short names, one of long names, and a single name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02593">2593</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;                                                     {</div>
<div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;            std::vector&lt;std::string&gt; short_names;</div>
<div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;            std::vector&lt;std::string&gt; long_names;</div>
<div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;            std::string pos_name;</div>
<div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160; </div>
<div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;            <span class="keywordflow">for</span> (std::string name : input) {</div>
<div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;                <span class="keywordflow">if</span> (name.length() == 0) {</div>
<div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;                }</div>
<div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;                <span class="keywordflow">if</span> (name.length() &gt; 1 &amp;&amp; name[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; name[1] != <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;                    <span class="keywordflow">if</span> (name.length() == 2 &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(name[1]))</div>
<div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;                        short_names.emplace_back(1, name[1]);</div>
<div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;                        <span class="keywordflow">throw</span> BadNameString::OneCharName(name);</div>
<div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name.length() &gt; 2 &amp;&amp; name.substr(0, 2) == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;                    name = name.substr(2);</div>
<div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">valid_name_string</a>(name))</div>
<div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;                        long_names.push_back(name);</div>
<div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;                        <span class="keywordflow">throw</span> BadNameString::BadLongName(name);</div>
<div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;-&quot;</span> || name == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;                    <span class="keywordflow">throw</span> BadNameString::DashesOnly(name);</div>
<div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;                    <span class="keywordflow">if</span> (pos_name.length() &gt; 0)</div>
<div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;                        <span class="keywordflow">throw</span> BadNameString::MultiPositionalNames(name);</div>
<div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;                    pos_name = name;</div>
<div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;                }</div>
<div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;            }</div>
<div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160; </div>
<div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;            <span class="keywordflow">return</span> std::tuple&lt;std::vector&lt;std::string&gt;, std::vector&lt;std::string&gt;, std::string&gt;(short_names, long_names, pos_name);</div>
<div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a3a05d1129df69e88135e178137b1fd89"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">CLI::detail::valid_first_char</a></div><div class="ttdeci">bool valid_first_char(T c)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00361">CLI11.hpp:361</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a4274628d24f9e3fbc719284f1db263b8"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">CLI::detail::valid_name_string</a></div><div class="ttdeci">bool valid_name_string(const std::string &amp;str)</div><div class="ttdoc">Verify an option/subcommand name.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00375">CLI11.hpp:375</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00692">CLI::BadNameString::BadLongName()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00695">CLI::BadNameString::DashesOnly()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00698">CLI::BadNameString::MultiPositionalNames()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00689">CLI::BadNameString::OneCharName()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00361">valid_first_char()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00375">valid_name_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l04490">CLI::Option::Option()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a23ae97bbbd9e400bd94b316dd865cb66_cgraph.svg" width="599" height="372"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a23ae97bbbd9e400bd94b316dd865cb66_icgraph.svg" width="370" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae89da9fa11d234a8bf504d6ec85133cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89da9fa11d234a8bf504d6ec85133cc">&#9670;&nbsp;</a></span>has_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::has_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if the flag definitions has possible false flags </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00432">432</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                                                                    {</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;            <span class="keywordflow">return</span> (flags.find_first_of(<span class="stringliteral">&quot;{!&quot;</span>) != std::string::npos);</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06332">CLI::App::_add_flag_internal()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ae89da9fa11d234a8bf504d6ec85133cc_icgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0b12b08c7bc02a39431b3da4f123e93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b12b08c7bc02a39431b3da4f123e93d">&#9670;&nbsp;</a></span>ini_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::ini_join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sepChar</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>arrayStart</em> = <code>'['</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>arrayEnd</em> = <code>']'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>stringQuote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>characterQuote</em> = <code>'\''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comma separated join, adds quotes if needed. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08942">8942</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08947"></a><span class="lineno"> 8947</span>&#160;                                                                {</div>
<div class="line"><a name="l08948"></a><span class="lineno"> 8948</span>&#160;            std::string joined;</div>
<div class="line"><a name="l08949"></a><span class="lineno"> 8949</span>&#160;            <span class="keywordflow">if</span> (args.size() &gt; 1 &amp;&amp; arrayStart != <span class="charliteral">&#39;\0&#39;</span>) {</div>
<div class="line"><a name="l08950"></a><span class="lineno"> 8950</span>&#160;                joined.push_back(arrayStart);</div>
<div class="line"><a name="l08951"></a><span class="lineno"> 8951</span>&#160;            }</div>
<div class="line"><a name="l08952"></a><span class="lineno"> 8952</span>&#160;            std::size_t start = 0;</div>
<div class="line"><a name="l08953"></a><span class="lineno"> 8953</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : args) {</div>
<div class="line"><a name="l08954"></a><span class="lineno"> 8954</span>&#160;                <span class="keywordflow">if</span> (start++ &gt; 0) {</div>
<div class="line"><a name="l08955"></a><span class="lineno"> 8955</span>&#160;                    joined.push_back(sepChar);</div>
<div class="line"><a name="l08956"></a><span class="lineno"> 8956</span>&#160;                    <span class="keywordflow">if</span> (isspace(sepChar) == 0) {</div>
<div class="line"><a name="l08957"></a><span class="lineno"> 8957</span>&#160;                        joined.push_back(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"><a name="l08958"></a><span class="lineno"> 8958</span>&#160;                    }</div>
<div class="line"><a name="l08959"></a><span class="lineno"> 8959</span>&#160;                }</div>
<div class="line"><a name="l08960"></a><span class="lineno"> 8960</span>&#160;                joined.append(<a class="code" href="namespace_c_l_i_1_1detail.html#a2382165480a50710d41e421dd54079a7">convert_arg_for_ini</a>(arg, stringQuote, characterQuote));</div>
<div class="line"><a name="l08961"></a><span class="lineno"> 8961</span>&#160;            }</div>
<div class="line"><a name="l08962"></a><span class="lineno"> 8962</span>&#160;            <span class="keywordflow">if</span> (args.size() &gt; 1 &amp;&amp; arrayEnd != <span class="charliteral">&#39;\0&#39;</span>) {</div>
<div class="line"><a name="l08963"></a><span class="lineno"> 8963</span>&#160;                joined.push_back(arrayEnd);</div>
<div class="line"><a name="l08964"></a><span class="lineno"> 8964</span>&#160;            }</div>
<div class="line"><a name="l08965"></a><span class="lineno"> 8965</span>&#160;            <span class="keywordflow">return</span> joined;</div>
<div class="line"><a name="l08966"></a><span class="lineno"> 8966</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a2382165480a50710d41e421dd54079a7"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a2382165480a50710d41e421dd54079a7">CLI::detail::convert_arg_for_ini</a></div><div class="ttdeci">std::string convert_arg_for_ini(const std::string &amp;arg, char stringQuote='&quot;', char characterQuote = '\'') </div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l08893">CLI11.hpp:8893</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l08893">convert_arg_for_ini()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09173">CLI::ConfigBase::to_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0b12b08c7bc02a39431b3da4f123e93d_cgraph.svg" width="759" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0b12b08c7bc02a39431b3da4f123e93d_icgraph.svg" width="347" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af6685ecdb07b40a316035bb4af9b02e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6685ecdb07b40a316035bb4af9b02e6">&#9670;&nbsp;</a></span>integral_conversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::integral_conversion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to an unsigned integral. </p>
<p>Convert to a signed integral. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01767">1767</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;                                                                             {</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;            <span class="keywordflow">if</span> (input.empty()) {</div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;            }</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;            <span class="keywordtype">char</span>* val = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;            std::uint64_t output_ll = std::strtoull(input.c_str(), &amp;val, 0);</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;            output = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(output_ll);</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;            <span class="keywordflow">if</span> (val == (input.c_str() + input.size()) &amp;&amp; <span class="keyword">static_cast&lt;</span>std::uint64_t<span class="keyword">&gt;</span>(output) == output_ll) {</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;            }</div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;            val = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;            std::int64_t output_sll = std::strtoll(input.c_str(), &amp;val, 0);</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;            <span class="keywordflow">if</span> (val == (input.c_str() + input.size())) {</div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;                output = (output_sll &lt; 0) ? static_cast&lt;T&gt;(0) : static_cast&lt;T&gt;(output_sll);</div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;                <span class="keywordflow">return</span> (<span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(output) == output_sll);</div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;            }</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l01854">lexical_cast()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af6685ecdb07b40a316035bb4af9b02e6_icgraph.svg" width="1024" height="718"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a53b46b96102830769cc02952392e782f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b46b96102830769cc02952392e782f">&#9670;&nbsp;</a></span>is_separator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::is_separator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a string is a container segment separator (empty or "%%") </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00393">393</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                                                       {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string sep(<span class="stringliteral">&quot;%%&quot;</span>);</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            <span class="keywordflow">return</span> (str.empty() || str == sep);</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05413">CLI::Option::_validate_results()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a53b46b96102830769cc02952392e782f_icgraph.svg" width="395" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac89ce22647a9f697b800d9c47b9d956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89ce22647a9f697b800d9c47b9d956f">&#9670;&nbsp;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::isalpha </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that str consists of letters only. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00399">399</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                                                  {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            <span class="keywordflow">return</span> std::all_of(str.begin(), str.end(), [](<span class="keywordtype">char</span> c) {</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                return std::isalpha(c, std::locale());</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;            });</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03819">CLI::AsNumberWithUnit::validate_mapping()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac89ce22647a9f697b800d9c47b9d956f_icgraph.svg" width="376" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8597debec6c8bc164109538253ffc623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8597debec6c8bc164109538253ffc623">&#9670;&nbsp;</a></span>join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callable , typename  = typename std::enable_if&lt;!std::is_constructible&lt;std::string, Callable&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to join a string from processed elements. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00208">208</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                                                                         {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            std::ostringstream s;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="keyword">auto</span> beg = std::begin(v);</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            <span class="keyword">auto</span> end = std::end(v);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="keyword">auto</span> loc = s.tellp();</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            <span class="keywordflow">while</span> (beg != end) {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                <span class="keyword">auto</span> nloc = s.tellp();</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                <span class="keywordflow">if</span> (nloc &gt; loc) {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                    s &lt;&lt; delim;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                    loc = nloc;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                }</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                s &lt;&lt; func(*beg++);</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            }</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            <span class="keywordflow">return</span> s.str();</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab351f13ec104e2cba19ec6baf4a552f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab351f13ec104e2cba19ec6baf4a552f6">&#9670;&nbsp;</a></span>join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to join a string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00192">192</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                                                          {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            std::ostringstream s;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="keyword">auto</span> beg = std::begin(v);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            <span class="keyword">auto</span> end = std::end(v);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            <span class="keywordflow">if</span> (beg != end)</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                s &lt;&lt; *beg++;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="keywordflow">while</span> (beg != end) {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                s &lt;&lt; delim &lt;&lt; *beg++;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="keywordflow">return</span> s.str();</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l07767">CLI::App::_process_requirements()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05453">CLI::Option::_reduce_results()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03641">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02641">CLI::ConfigItem::fullname()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03359">generate_map()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03343">generate_set()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04987">CLI::Option::get_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09333">CLI::Formatter::make_usage()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l08827">CLI::FailureMessage::simple()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ab351f13ec104e2cba19ec6baf4a552f6_icgraph.svg" width="842" height="754"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab6647281bf64bba7b07737297ae1895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6647281bf64bba7b07737297ae1895d">&#9670;&nbsp;</a></span>lexical_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AssignTo , typename ConvertTo , enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::lexical_assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignTo &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a value through lexical cast operations. </p>
<p>Assign a value from a lexical cast through constructing a value and move assigning it.</p>
<p>Assign a value converted from a string in lexical cast to the output value directly.</p>
<p>Assign a value through lexical cast operations Strings can be empty so we need to do a little different</p>
<p>Assign a value through lexical cast operations for int compatible values mainly for atomic operations on some compilers </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02068">2068</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;                                                                      {</div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">lexical_cast</a>(input, output);</div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01854">lexical_cast()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ab6647281bf64bba7b07737297ae1895d_cgraph.svg" width="563" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af286727de86fce444325681379e2c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af286727de86fce444325681379e2c511">&#9670;&nbsp;</a></span>lexical_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::lexical_cast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer conversion. </p>
<p>Non-string parsable by a stream.</p>
<p>Non-string convertible from an int.</p>
<p>Assignable from double.</p>
<p>Assignable from int.</p>
<p>Assignable from double or int.</p>
<p>wrapper types</p>
<p>Enumerations.</p>
<p>String and similar constructible and copy assignment.</p>
<p>String and similar direct assignment.</p>
<p>complex</p>
<p>Floats.</p>
<p>Boolean values.</p>
<p>char values </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01854">1854</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;                                                             {</div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">integral_conversion</a>(input, output);</div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_af6685ecdb07b40a316035bb4af9b02e6"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">CLI::detail::integral_conversion</a></div><div class="ttdeci">bool integral_conversion(const std::string &amp;input, T &amp;output) noexcept</div><div class="ttdoc">Convert to an unsigned integral.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l01767">CLI11.hpp:1767</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01767">integral_conversion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06378">CLI::App::add_flag()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06408">CLI::App::add_flag_callback()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06423">CLI::App::add_flag_function()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03303">CLI::Bound::Bound()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03641">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08893">convert_arg_for_ini()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03161">CLI::detail::IPV4Validator::IPV4Validator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03496">CLI::IsMember::IsMember()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02068">lexical_assign()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03575">CLI::Transformer::Transformer()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03206">CLI::TypeValidator&lt; DesiredType &gt;::TypeValidator()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af286727de86fce444325681379e2c511_cgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af286727de86fce444325681379e2c511_icgraph.svg" width="831" height="718"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acae078b951ab0e11b84dffe200d0049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae078b951ab0e11b84dffe200d0049c">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from left of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00239">239</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                                                {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.begin(), str.end(), [](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                return !std::isspace&lt;char&gt;(ch, std::locale());</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            });</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            str.erase(str.begin(), it);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l00275">trim()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_acae078b951ab0e11b84dffe200d0049c_icgraph.svg" width="742" height="236"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2cb44de7c57bbb1384f737dc2f04265b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb44de7c57bbb1384f737dc2f04265b">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from left of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00248">248</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                                                                         {</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.begin(), str.end(), [&amp;filter](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                return filter.find(ch) == std::string::npos;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            });</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            str.erase(str.begin(), it);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03925">split_program_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a2cb44de7c57bbb1384f737dc2f04265b_icgraph.svg" width="480" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac96583f0b43752f7fa77a6c24dae4802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96583f0b43752f7fa77a6c24dae4802">&#9670;&nbsp;</a></span>overflowCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_signed&lt;T&gt;::value, T&gt;::type CLI::detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on signed numbers. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03434">3434</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03434"></a><span class="lineno"> 3434</span>&#160;                                                                                                        {</div>
<div class="line"><a name="l03435"></a><span class="lineno"> 3435</span>&#160;            <span class="keywordflow">if</span> ((a &gt; 0) == (b &gt; 0)) {</div>
<div class="line"><a name="l03436"></a><span class="lineno"> 3436</span>&#160;                <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::max)() / (std::abs)(a) &lt; (std::abs)(b));</div>
<div class="line"><a name="l03437"></a><span class="lineno"> 3437</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l03438"></a><span class="lineno"> 3438</span>&#160;                <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::min)() / (std::abs)(a) &gt; -(std::abs)(b));</div>
<div class="line"><a name="l03439"></a><span class="lineno"> 3439</span>&#160;            }</div>
<div class="line"><a name="l03440"></a><span class="lineno"> 3440</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9da7d60b3b5738079257829c777c9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9da7d60b3b5738079257829c777c9c7">&#9670;&nbsp;</a></span>overflowCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_signed&lt;T&gt;::value, T&gt;::type CLI::detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on unsigned numbers. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03443">3443</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03443"></a><span class="lineno"> 3443</span>&#160;                                                                                                         {</div>
<div class="line"><a name="l03444"></a><span class="lineno"> 3444</span>&#160;            <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::max)() / a &lt; b);</div>
<div class="line"><a name="l03445"></a><span class="lineno"> 3445</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03449">checked_multiply()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ad9da7d60b3b5738079257829c777c9c7_icgraph.svg" width="830" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a73b9afbe8a438ab30291d35f1f24c87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b9afbe8a438ab30291d35f1f24c87c">&#9670;&nbsp;</a></span>remove_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLI::detail::remove_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00436">436</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                                                                 {</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            <span class="keyword">auto</span> loc = flags.find_first_of(<span class="charliteral">&#39;{&#39;</span>, 2);</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keywordflow">while</span> (loc != std::string::npos) {</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                <span class="keyword">auto</span> finish = flags.find_first_of(<span class="stringliteral">&quot;},&quot;</span>, loc + 1);</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                <span class="keywordflow">if</span> ((finish != std::string::npos) &amp;&amp; (flags[finish] == <span class="charliteral">&#39;}&#39;</span>)) {</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                    flags.erase(flags.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(loc), flags.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(finish) + 1);</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                }</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                loc = flags.find_first_of(<span class="charliteral">&#39;{&#39;</span>, loc + 1);</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            }</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            flags.erase(std::remove(flags.begin(), flags.end(), <span class="charliteral">&#39;!&#39;</span>), flags.end());</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06332">CLI::App::_add_flag_internal()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a73b9afbe8a438ab30291d35f1f24c87c_icgraph.svg" width="363" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a242fa1bec3353c591a730efc6307f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242fa1bec3353c591a730efc6307f3ea">&#9670;&nbsp;</a></span>remove_quotes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::remove_quotes </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove quotes at the front and back of a string either '"' or '\'' </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00291">291</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                                                        {</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="keywordflow">if</span> (str.length() &gt; 1 &amp;&amp; (str.front() == <span class="charliteral">&#39;&quot;&#39;</span> || str.front() == <span class="charliteral">&#39;\&#39;&#39;</span>)) {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                <span class="keywordflow">if</span> (str.front() == str.back()) {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                    str.pop_back();</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                    str.erase(str.begin(), str.begin() + 1);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                }</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            }</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09041">CLI::ConfigBase::from_config()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l08968">generate_parents()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a242fa1bec3353c591a730efc6307f3ea_icgraph.svg" width="791" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5359a7a0e33366a12e15523b100f591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5359a7a0e33366a12e15523b100f591a">&#9670;&nbsp;</a></span>remove_underscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::remove_underscore </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove underscores from a string </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00414">414</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                                                          {</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;            str.erase(std::remove(std::begin(str), std::end(str), <span class="charliteral">&#39;_&#39;</span>), std::end(str));</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05098">CLI::Option::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l07422">CLI::App::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00450">find_member()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03711">CLI::ignore_underscore()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a5359a7a0e33366a12e15523b100f591a_icgraph.svg" width="1302" height="316"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af74b520ee1011d38fde77f907ddfea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74b520ee1011d38fde77f907ddfea40">&#9670;&nbsp;</a></span>rjoin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::rjoin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a string in reverse order. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00226">226</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                                                           {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            std::ostringstream s;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            <span class="keywordflow">for</span> (std::size_t start = 0; start &lt; v.size(); start++) {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                <span class="keywordflow">if</span> (start &gt; 0)</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                    s &lt;&lt; delim;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                s &lt;&lt; v[v.size() - start - 1];</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            }</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            <span class="keywordflow">return</span> s.str();</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed9338ae7c45f34f8240a31325d8d71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9338ae7c45f34f8240a31325d8d71c">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from right of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00257">257</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                                                {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.rbegin(), str.rend(), [](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                return !std::isspace&lt;char&gt;(ch, std::locale());</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            });</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            str.erase(it.base(), str.end());</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00275">trim()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aed9338ae7c45f34f8240a31325d8d71c_icgraph.svg" width="742" height="240"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a27306fb661edc7a7017a09a0e9ee7b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27306fb661edc7a7017a09a0e9ee7b18">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from right of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00266">266</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                                                                         {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.rbegin(), str.rend(), [&amp;filter](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                return filter.find(ch) == std::string::npos;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            });</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            str.erase(it.base(), str.end());</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03925">split_program_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a27306fb661edc7a7017a09a0e9ee7b18_icgraph.svg" width="480" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa4b4a0a97c9b07110595765887647385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b4a0a97c9b07110595765887647385">&#9670;&nbsp;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V , enable_if_t&lt;!has_find&lt; T, V &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::pair&lt;bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function. </p>
<p>A search function that uses the built in find function. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03392">3392</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03392"></a><span class="lineno"> 3392</span>&#160;                                                                                                             {</div>
<div class="line"><a name="l03393"></a><span class="lineno"> 3393</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03394"></a><span class="lineno"> 3394</span>&#160;            <span class="keyword">auto</span>&amp; setref = <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(set);</div>
<div class="line"><a name="l03395"></a><span class="lineno"> 3395</span>&#160;            <span class="keyword">auto</span> it = std::find_if(std::begin(setref), std::end(setref), [&amp;val](decltype(*std::begin(setref)) v) {</div>
<div class="line"><a name="l03396"></a><span class="lineno"> 3396</span>&#160;                <span class="keywordflow">return</span> (detail::pair_adaptor&lt;element_t&gt;::first(v) == val);</div>
<div class="line"><a name="l03397"></a><span class="lineno"> 3397</span>&#160;            });</div>
<div class="line"><a name="l03398"></a><span class="lineno"> 3398</span>&#160;            <span class="keywordflow">return</span> {(it != std::end(setref)), it};</div>
<div class="line"><a name="l03399"></a><span class="lineno"> 3399</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03332">smart_deref()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03641">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="http__utils_8cpp_source.html#l00178">httputils::ci_contains()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03496">CLI::IsMember::IsMember()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03575">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aa4b4a0a97c9b07110595765887647385_cgraph.svg" width="331" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aa4b4a0a97c9b07110595765887647385_icgraph.svg" width="1811" height="964"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abcb81a667288aa66a4576a06b9322092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb81a667288aa66a4576a06b9322092">&#9670;&nbsp;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; V(V)&gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::pair&lt;bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function with a filter function. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03411">3411</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03412"></a><span class="lineno"> 3412</span>&#160;                                                                         {</div>
<div class="line"><a name="l03413"></a><span class="lineno"> 3413</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03414"></a><span class="lineno"> 3414</span>&#160;            <span class="comment">// do the potentially faster first search</span></div>
<div class="line"><a name="l03415"></a><span class="lineno"> 3415</span>&#160;            <span class="keyword">auto</span> res = <a class="code" href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">search</a>(set, val);</div>
<div class="line"><a name="l03416"></a><span class="lineno"> 3416</span>&#160;            <span class="keywordflow">if</span> ((res.first) || (!(filter_function))) {</div>
<div class="line"><a name="l03417"></a><span class="lineno"> 3417</span>&#160;                <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l03418"></a><span class="lineno"> 3418</span>&#160;            }</div>
<div class="line"><a name="l03419"></a><span class="lineno"> 3419</span>&#160;            <span class="comment">// if we haven&#39;t found it do the longer linear search with all the element translations</span></div>
<div class="line"><a name="l03420"></a><span class="lineno"> 3420</span>&#160;            <span class="keyword">auto</span>&amp; setref = <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(set);</div>
<div class="line"><a name="l03421"></a><span class="lineno"> 3421</span>&#160;            <span class="keyword">auto</span> it = std::find_if(std::begin(setref), std::end(setref), [&amp;](decltype(*std::begin(setref)) v) {</div>
<div class="line"><a name="l03422"></a><span class="lineno"> 3422</span>&#160;                V a{detail::pair_adaptor&lt;element_t&gt;::first(v)};</div>
<div class="line"><a name="l03423"></a><span class="lineno"> 3423</span>&#160;                a = filter_function(a);</div>
<div class="line"><a name="l03424"></a><span class="lineno"> 3424</span>&#160;                <span class="keywordflow">return</span> (a == val);</div>
<div class="line"><a name="l03425"></a><span class="lineno"> 3425</span>&#160;            });</div>
<div class="line"><a name="l03426"></a><span class="lineno"> 3426</span>&#160;            <span class="keywordflow">return</span> {(it != std::end(setref)), it};</div>
<div class="line"><a name="l03427"></a><span class="lineno"> 3427</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_abcb81a667288aa66a4576a06b9322092"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">CLI::detail::search</a></div><div class="ttdeci">auto search(const T &amp;set, const V &amp;val, const std::function&lt; V(V)&gt; &amp;filter_function) -&gt; std::pair&lt; bool, decltype(std::begin(detail::smart_deref(set)))&gt;</div><div class="ttdoc">A search function with a filter function.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03411">CLI11.hpp:3411</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01047">CLI::detail::pair_adaptor&lt; T, _ &gt;::first()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03332">smart_deref()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_abcb81a667288aa66a4576a06b9322092_cgraph.svg" width="375" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adcd67b783a1c4441c89f071774ac398b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd67b783a1c4441c89f071774ac398b">&#9670;&nbsp;</a></span>smart_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt;T&gt;::type&amp; CLI::detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03338">3338</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160;                                                                   {</div>
<div class="line"><a name="l03339"></a><span class="lineno"> 3339</span>&#160;            <span class="keywordflow">return</span> value;</div>
<div class="line"><a name="l03340"></a><span class="lineno"> 3340</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c6cf48feae9d909d52e7b4c346cba29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6cf48feae9d909d52e7b4c346cba29">&#9670;&nbsp;</a></span>smart_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(*value) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03332">3332</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;                                                      {</div>
<div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;            <span class="keywordflow">return</span> *value;</div>
<div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03641">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03359">generate_map()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03343">generate_set()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03496">CLI::IsMember::IsMember()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03392">search()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03575">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0c6cf48feae9d909d52e7b4c346cba29_icgraph.svg" width="2043" height="964"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9e78d046d8a9c2d6f246bd1e36e57ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78d046d8a9c2d6f246bd1e36e57ec6">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string by a delim. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00174">174</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                                                                          {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            std::vector&lt;std::string&gt; elems;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="comment">// Check to see if empty string, give consistent result</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="keywordflow">if</span> (s.empty()) {</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                elems.emplace_back();</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                std::stringstream ss;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                ss.str(s);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                std::string item;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                <span class="keywordflow">while</span> (std::getline(ss, item, delim)) {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                    elems.push_back(item);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                }</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            }</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">return</span> elems;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05540">CLI::Option::_add_result()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08968">generate_parents()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03161">CLI::detail::IPV4Validator::IPV4Validator()</a>, <a class="el" href="http__utils_8cpp_source.html#l00091">httputils::str_split()</a>, and <a class="el" href="http__utils_8cpp_source.html#l00105">httputils::str_split_last()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9e78d046d8a9c2d6f246bd1e36e57ec6_icgraph.svg" width="1058" height="472"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0de15b0ba0d12c9170d15693477808ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de15b0ba0d12c9170d15693477808ed">&#9670;&nbsp;</a></span>split_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::split_long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02521">2521</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;                                                                                            {</div>
<div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;            <span class="keywordflow">if</span> (current.size() &gt; 2 &amp;&amp; current.substr(0, 2) == <span class="stringliteral">&quot;--&quot;</span> &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(current[2])) {</div>
<div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;                <span class="keyword">auto</span> loc = current.find_first_of(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;                <span class="keywordflow">if</span> (loc != std::string::npos) {</div>
<div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;                    name = current.substr(2, loc - 2);</div>
<div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;                    value = current.substr(loc + 1);</div>
<div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;                    name = current.substr(2);</div>
<div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;                    value = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;                }</div>
<div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;            }</div>
<div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00361">valid_first_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08350">CLI::App::_parse_arg()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l07625">CLI::App::_recognize()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0de15b0ba0d12c9170d15693477808ed_cgraph.svg" width="344" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0de15b0ba0d12c9170d15693477808ed_icgraph.svg" width="580" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abf817a10b92907070c02b752c37aa09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf817a10b92907070c02b752c37aa09d">&#9670;&nbsp;</a></span>split_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split_names </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02553">2553</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;                                                                   {</div>
<div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;            std::vector&lt;std::string&gt; output;</div>
<div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;            std::size_t val;</div>
<div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;            <span class="keywordflow">while</span> ((val = current.find(<span class="stringliteral">&quot;,&quot;</span>)) != std::string::npos) {</div>
<div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;                output.push_back(<a class="code" href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">trim_copy</a>(current.substr(0, val)));</div>
<div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;                current = current.substr(val + 1);</div>
<div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;            }</div>
<div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;            output.push_back(<a class="code" href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">trim_copy</a>(current));</div>
<div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;            <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a09bd3735d1104a453e5376a43140d5a8"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">CLI::detail::trim_copy</a></div><div class="ttdeci">std::string trim_copy(const std::string &amp;str, const std::string &amp;filter)</div><div class="ttdoc">Make a copy of the string and then trim it, any filter string can be used (any char in string is filt...</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00318">CLI11.hpp:318</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00318">trim_copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l02565">get_default_flag_values()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l04490">CLI::Option::Option()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_abf817a10b92907070c02b752c37aa09d_cgraph.svg" width="687" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_abf817a10b92907070c02b752c37aa09d_icgraph.svg" width="546" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a33c9893591d9e9d3d4c9d7282d50b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c9893591d9e9d3d4c9d7282d50b9d2">&#9670;&nbsp;</a></span>split_program_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; CLI::detail::split_program_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>commandline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a program name and command line arguments the string is assumed to contain a file name followed by other arguments the return value contains is a pair with the first argument containing the program name and the second everything else. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03925">3925</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03925"></a><span class="lineno"> 3925</span>&#160;                                                                                       {</div>
<div class="line"><a name="l03926"></a><span class="lineno"> 3926</span>&#160;            <span class="comment">// try to determine the programName</span></div>
<div class="line"><a name="l03927"></a><span class="lineno"> 3927</span>&#160;            std::pair&lt;std::string, std::string&gt; vals;</div>
<div class="line"><a name="l03928"></a><span class="lineno"> 3928</span>&#160;            <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(commandline);</div>
<div class="line"><a name="l03929"></a><span class="lineno"> 3929</span>&#160;            <span class="keyword">auto</span> esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><a name="l03930"></a><span class="lineno"> 3930</span>&#160;            <span class="keywordflow">while</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">detail::check_path</a>(commandline.substr(0, esp).c_str()) != path_type::file) {</div>
<div class="line"><a name="l03931"></a><span class="lineno"> 3931</span>&#160;                esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, esp + 1);</div>
<div class="line"><a name="l03932"></a><span class="lineno"> 3932</span>&#160;                <span class="keywordflow">if</span> (esp == std::string::npos) {</div>
<div class="line"><a name="l03933"></a><span class="lineno"> 3933</span>&#160;                    <span class="comment">// if we have reached the end and haven&#39;t found a valid file just assume the first argument is the</span></div>
<div class="line"><a name="l03934"></a><span class="lineno"> 3934</span>&#160;                    <span class="comment">// program name</span></div>
<div class="line"><a name="l03935"></a><span class="lineno"> 3935</span>&#160;                    <span class="keywordflow">if</span> (commandline[0] == <span class="charliteral">&#39;&quot;&#39;</span> || commandline[0] == <span class="charliteral">&#39;\&#39;&#39;</span> || commandline[0] == <span class="charliteral">&#39;`&#39;</span>) {</div>
<div class="line"><a name="l03936"></a><span class="lineno"> 3936</span>&#160;                        <span class="keywordtype">bool</span> embeddedQuote = <span class="keyword">false</span>;</div>
<div class="line"><a name="l03937"></a><span class="lineno"> 3937</span>&#160;                        <span class="keyword">auto</span> keyChar = commandline[0];</div>
<div class="line"><a name="l03938"></a><span class="lineno"> 3938</span>&#160;                        <span class="keyword">auto</span> end = commandline.find_first_of(keyChar, 1);</div>
<div class="line"><a name="l03939"></a><span class="lineno"> 3939</span>&#160;                        <span class="keywordflow">while</span> ((end != std::string::npos) &amp;&amp; (commandline[end - 1] == <span class="charliteral">&#39;\\&#39;</span>)) { <span class="comment">// deal with escaped quotes</span></div>
<div class="line"><a name="l03940"></a><span class="lineno"> 3940</span>&#160;                            end = commandline.find_first_of(keyChar, end + 1);</div>
<div class="line"><a name="l03941"></a><span class="lineno"> 3941</span>&#160;                            embeddedQuote = <span class="keyword">true</span>;</div>
<div class="line"><a name="l03942"></a><span class="lineno"> 3942</span>&#160;                        }</div>
<div class="line"><a name="l03943"></a><span class="lineno"> 3943</span>&#160;                        <span class="keywordflow">if</span> (end != std::string::npos) {</div>
<div class="line"><a name="l03944"></a><span class="lineno"> 3944</span>&#160;                            vals.first = commandline.substr(1, end - 1);</div>
<div class="line"><a name="l03945"></a><span class="lineno"> 3945</span>&#160;                            esp = end + 1;</div>
<div class="line"><a name="l03946"></a><span class="lineno"> 3946</span>&#160;                            <span class="keywordflow">if</span> (embeddedQuote) {</div>
<div class="line"><a name="l03947"></a><span class="lineno"> 3947</span>&#160;                                vals.first = <a class="code" href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">find_and_replace</a>(vals.first, std::string(<span class="stringliteral">&quot;\\&quot;</span>) + keyChar, std::string(1, keyChar));</div>
<div class="line"><a name="l03948"></a><span class="lineno"> 3948</span>&#160;                            }</div>
<div class="line"><a name="l03949"></a><span class="lineno"> 3949</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l03950"></a><span class="lineno"> 3950</span>&#160;                            esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><a name="l03951"></a><span class="lineno"> 3951</span>&#160;                        }</div>
<div class="line"><a name="l03952"></a><span class="lineno"> 3952</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l03953"></a><span class="lineno"> 3953</span>&#160;                        esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><a name="l03954"></a><span class="lineno"> 3954</span>&#160;                    }</div>
<div class="line"><a name="l03955"></a><span class="lineno"> 3955</span>&#160; </div>
<div class="line"><a name="l03956"></a><span class="lineno"> 3956</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l03957"></a><span class="lineno"> 3957</span>&#160;                }</div>
<div class="line"><a name="l03958"></a><span class="lineno"> 3958</span>&#160;            }</div>
<div class="line"><a name="l03959"></a><span class="lineno"> 3959</span>&#160;            <span class="keywordflow">if</span> (vals.first.empty()) {</div>
<div class="line"><a name="l03960"></a><span class="lineno"> 3960</span>&#160;                vals.first = commandline.substr(0, esp);</div>
<div class="line"><a name="l03961"></a><span class="lineno"> 3961</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a>(vals.first);</div>
<div class="line"><a name="l03962"></a><span class="lineno"> 3962</span>&#160;            }</div>
<div class="line"><a name="l03963"></a><span class="lineno"> 3963</span>&#160; </div>
<div class="line"><a name="l03964"></a><span class="lineno"> 3964</span>&#160;            <span class="comment">// strip the program name</span></div>
<div class="line"><a name="l03965"></a><span class="lineno"> 3965</span>&#160;            vals.second = (esp != std::string::npos) ? commandline.substr(esp + 1) : std::string{};</div>
<div class="line"><a name="l03966"></a><span class="lineno"> 3966</span>&#160;            <a class="code" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a>(vals.second);</div>
<div class="line"><a name="l03967"></a><span class="lineno"> 3967</span>&#160;            <span class="keywordflow">return</span> vals;</div>
<div class="line"><a name="l03968"></a><span class="lineno"> 3968</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a197be0b62b4d4deef0f5cac600a6b759"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">CLI::detail::check_path</a></div><div class="ttdeci">path_type check_path(const char *file) noexcept</div><div class="ttdoc">get the type of the path from a file name</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03077">CLI11.hpp:3077</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a27306fb661edc7a7017a09a0e9ee7b18"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">CLI::detail::rtrim</a></div><div class="ttdeci">std::string &amp; rtrim(std::string &amp;str, const std::string &amp;filter)</div><div class="ttdoc">Trim anything from right of string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00266">CLI11.hpp:266</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a2cb44de7c57bbb1384f737dc2f04265b"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">CLI::detail::ltrim</a></div><div class="ttdeci">std::string &amp; ltrim(std::string &amp;str, const std::string &amp;filter)</div><div class="ttdoc">Trim anything from left of string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00248">CLI11.hpp:248</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a42ffd53b391fe1eebc540f26c8825692"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">CLI::detail::trim</a></div><div class="ttdeci">std::string &amp; trim(std::string &amp;str, const std::string filter)</div><div class="ttdoc">Trim anything from string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00280">CLI11.hpp:280</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_ab39b1977d7375250cc57d90723cf1554"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">CLI::detail::find_and_replace</a></div><div class="ttdeci">std::string find_and_replace(std::string str, std::string from, std::string to)</div><div class="ttdoc">Find and replace a substring with another substring.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00420">CLI11.hpp:420</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03077">check_path()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00420">find_and_replace()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00248">ltrim()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00266">rtrim()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00280">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06775">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a33c9893591d9e9d3d4c9d7282d50b9d2_cgraph.svg" width="531" height="282"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a33c9893591d9e9d3d4c9d7282d50b9d2_icgraph.svg" width="306" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1e6f215bcb727ff49f126ac3e1a13e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6f215bcb727ff49f126ac3e1a13e40">&#9670;&nbsp;</a></span>split_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::split_short </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02511">2511</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;                                                                                            {</div>
<div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;            <span class="keywordflow">if</span> (current.size() &gt; 1 &amp;&amp; current[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(current[1])) {</div>
<div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;                name = current.substr(1, 1);</div>
<div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;                rest = current.substr(2);</div>
<div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;            }</div>
<div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00361">valid_first_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08350">CLI::App::_parse_arg()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l07625">CLI::App::_recognize()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a1e6f215bcb727ff49f126ac3e1a13e40_cgraph.svg" width="308" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a1e6f215bcb727ff49f126ac3e1a13e40_icgraph.svg" width="544" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aad6e8a6354d9645d3da614f6734573a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6e8a6354d9645d3da614f6734573a8">&#9670;&nbsp;</a></span>split_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split_up </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'\0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string '"one two" "three"' into 'one two', 'three' Quote characters can be &lsquo; &rsquo; or " </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00490">490</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            <span class="keyword">const</span> std::string delims(<span class="stringliteral">&quot;\&#39;\&quot;`&quot;</span>);</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            <span class="keyword">auto</span> find_ws = [delimiter](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                <span class="keywordflow">return</span> (delimiter == <span class="charliteral">&#39;\0&#39;</span>) ? (std::isspace&lt;char&gt;(ch, std::locale()) != 0) : (ch == delimiter);</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            };</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(str);</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160; </div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            std::vector&lt;std::string&gt; output;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            <span class="keywordtype">bool</span> embeddedQuote = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            <span class="keywordtype">char</span> keyChar = <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            <span class="keywordflow">while</span> (!str.empty()) {</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                <span class="keywordflow">if</span> (delims.find_first_of(str[0]) != std::string::npos) {</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                    keyChar = str[0];</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                    <span class="keyword">auto</span> end = str.find_first_of(keyChar, 1);</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                    <span class="keywordflow">while</span> ((end != std::string::npos) &amp;&amp; (str[end - 1] == <span class="charliteral">&#39;\\&#39;</span>)) { <span class="comment">// deal with escaped quotes</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                        end = str.find_first_of(keyChar, end + 1);</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                        embeddedQuote = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                    }</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                    <span class="keywordflow">if</span> (end != std::string::npos) {</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                        output.push_back(str.substr(1, end - 1));</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                        <span class="keywordflow">if</span> (end + 2 &lt; str.size()) {</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                            str = str.substr(end + 2);</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                            str.clear();</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                        }</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160; </div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                        output.push_back(str.substr(1));</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                        str = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                    }</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                    <span class="keyword">auto</span> it = std::find_if(std::begin(str), std::end(str), find_ws);</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                    <span class="keywordflow">if</span> (it != std::end(str)) {</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                        std::string value = std::string(str.begin(), it);</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                        output.push_back(value);</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                        str = std::string(it + 1, str.end());</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                        output.push_back(str);</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                        str = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                    }</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                }</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                <span class="comment">// transform any embedded quotes into the regular character</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                <span class="keywordflow">if</span> (embeddedQuote) {</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                    output.back() = <a class="code" href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">find_and_replace</a>(output.back(), std::string(<span class="stringliteral">&quot;\\&quot;</span>) + keyChar, std::string(1, keyChar));</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                    embeddedQuote = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                }</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(str);</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            }</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00420">find_and_replace()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00275">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09041">CLI::ConfigBase::from_config()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l06775">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aad6e8a6354d9645d3da614f6734573a8_cgraph.svg" width="531" height="130"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aad6e8a6354d9645d3da614f6734573a8_icgraph.svg" width="368" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aadbd2b5b93afe2f10427dd6e32639b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbd2b5b93afe2f10427dd6e32639b0c">&#9670;&nbsp;</a></span>split_windows_style()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::split_windows_style </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02537">2537</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;            <span class="keywordflow">if</span> (current.size() &gt; 1 &amp;&amp; current[0] == <span class="charliteral">&#39;/&#39;</span> &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(current[1])) {</div>
<div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;                <span class="keyword">auto</span> loc = current.find_first_of(<span class="charliteral">&#39;:&#39;</span>);</div>
<div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;                <span class="keywordflow">if</span> (loc != std::string::npos) {</div>
<div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;                    name = current.substr(1, loc - 1);</div>
<div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;                    value = current.substr(loc + 1);</div>
<div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;                    name = current.substr(1);</div>
<div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;                    value = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;                }</div>
<div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;            }</div>
<div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00361">valid_first_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08350">CLI::App::_parse_arg()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l07625">CLI::App::_recognize()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aadbd2b5b93afe2f10427dd6e32639b0c_cgraph.svg" width="311" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aadbd2b5b93afe2f10427dd6e32639b0c_icgraph.svg" width="547" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af45abf683b881127298aa28b3c4e6cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45abf683b881127298aa28b3c4e6cf5">&#9670;&nbsp;</a></span>to_flag_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t CLI::detail::to_flag_value </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a flag into an integer value typically binary flags. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01807">1807</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;                                                       {</div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string trueString(<span class="stringliteral">&quot;true&quot;</span>);</div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string falseString(<span class="stringliteral">&quot;false&quot;</span>);</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;            <span class="keywordflow">if</span> (val == trueString) {</div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;                <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;            }</div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;            <span class="keywordflow">if</span> (val == falseString) {</div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;                <span class="keywordflow">return</span> -1;</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;            }</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;            val = <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(val);</div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;            std::int64_t ret;</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;            <span class="keywordflow">if</span> (val.size() == 1) {</div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;                <span class="keywordflow">if</span> (val[0] &gt;= <span class="charliteral">&#39;1&#39;</span> &amp;&amp; val[0] &lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;                    <span class="keywordflow">return</span> (<span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(val[0]) - <span class="charliteral">&#39;0&#39;</span>);</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;                }</div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;                <span class="keywordflow">switch</span> (val[0]) {</div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:</div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>:</div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>:</div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;-&#39;</span>:</div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;                        ret = -1;</div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>:</div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;y&#39;</span>:</div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>:</div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;                        ret = 1;</div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;                        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;unrecognized character&quot;</span>);</div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;                }</div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;                <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;            }</div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;            <span class="keywordflow">if</span> (val == trueString || val == <span class="stringliteral">&quot;on&quot;</span> || val == <span class="stringliteral">&quot;yes&quot;</span> || val == <span class="stringliteral">&quot;enable&quot;</span>) {</div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;                ret = 1;</div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val == falseString || val == <span class="stringliteral">&quot;off&quot;</span> || val == <span class="stringliteral">&quot;no&quot;</span> || val == <span class="stringliteral">&quot;disable&quot;</span>) {</div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;                ret = -1;</div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;                ret = std::stoll(val);</div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;            }</div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;            <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00406">to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05146">CLI::Option::get_flag_value()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af45abf683b881127298aa28b3c4e6cf5_cgraph.svg" width="350" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af45abf683b881127298aa28b3c4e6cf5_icgraph.svg" width="574" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae83709ec148057ec53df4383645727e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83709ec148057ec53df4383645727e9">&#9670;&nbsp;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a lower case version of a string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00406">406</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                                                 {</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;            std::transform(std::begin(str), std::end(str), std::begin(str), [](<span class="keyword">const</span> std::string::value_type&amp; x) {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                <span class="keywordflow">return</span> std::tolower(x, std::locale());</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;            });</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05098">CLI::Option::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l07422">CLI::App::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00450">find_member()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09041">CLI::ConfigBase::from_config()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08968">generate_parents()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03706">CLI::ignore_case()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09409">CLI::Formatter::make_subcommands()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l01807">to_flag_value()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03819">CLI::AsNumberWithUnit::validate_mapping()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ae83709ec148057ec53df4383645727e9_icgraph.svg" width="1315" height="554"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4e5965e3013bad7369e985e2f2fd42f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5965e3013bad7369e985e2f2fd42f4">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a string from the object. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01235">1235</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;                                            {</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;            <span class="keywordflow">return</span> std::string(value);</div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c070858740ce15aaecb1c5f04e21a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c070858740ce15aaecb1c5f04e21a09">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (streaming must be supported for that type) </p>
<p>convert a readable container to a string</p>
<p>If conversion is not supported, return an empty string (streaming is not supported for that type) </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01244">1244</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;                                       {</div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;            std::stringstream stream;</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;            stream &lt;&lt; value;</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;            <span class="keywordflow">return</span> stream.str();</div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l00849">CLI::ArgumentMismatch::AtLeast()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00852">CLI::ArgumentMismatch::AtMost()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l01279">checked_to_string()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05146">CLI::Option::get_flag_value()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06579">CLI::App::get_subcommand()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06607">CLI::App::get_subcommand_ptr()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09307">CLI::Formatter::make_description()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00814">CLI::RequiredError::Option()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00861">CLI::ArgumentMismatch::PartialType()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00808">CLI::RequiredError::Subcommand()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00855">CLI::ArgumentMismatch::TypedAtLeast()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l01290">value_string()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9c070858740ce15aaecb1c5f04e21a09_icgraph.svg" width="907" height="787"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0e94052d485636fc9f18c21009026577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e94052d485636fc9f18c21009026577">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(std::forward&lt;T&gt;(value)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (directly forward if this can become a string) </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01227">1227</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;                                                                    {</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;            <span class="keywordflow">return</span> std::forward&lt;T&gt;(value);</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03303">CLI::Bound::Bound()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03641">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_maria_d_b_auto_commit_command_8cpp_source.html#l00054">database::mariadb::commands::async::MariaDBAutoCommitCommand::commandInfo()</a>, <a class="el" href="_maria_d_b_connect_command_8cpp_source.html#l00070">database::mariadb::commands::async::MariaDBConnectCommand::commandInfo()</a>, <a class="el" href="un_2config_2_config_address_8cpp_source.html#l00035">net::un::config::ConfigAddress&lt; ConfigAddressTypeT &gt;::ConfigAddress()</a>, <a class="el" href="_config_cluster_8cpp_source.html#l00031">net::config::ConfigCluster::ConfigCluster()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05371">CLI::Option::default_val()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03359">generate_map()</a>, <a class="el" href="_event_loop_8cpp_source.html#l00046">core::getTickCounterAsString()</a>, <a class="el" href="web_2http_2client_2_request_8cpp_source.html#l00185">web::http::client::Request::send()</a>, <a class="el" href="web_2http_2server_2_response_8cpp_source.html#l00073">web::http::server::Response::send()</a>, <a class="el" href="web_2http_2server_2_response_8cpp_source.html#l00178">web::http::server::Response::sendFile()</a>, <a class="el" href="web_2http_2client_2_request_8cpp_source.html#l00143">web::http::client::Request::sendHeader()</a>, <a class="el" href="web_2http_2server_2_response_8cpp_source.html#l00205">web::http::server::Response::sendHeader()</a>, <a class="el" href="in_2_socket_address_8cpp_source.html#l00132">net::in::SocketAddress::toString()</a>, <a class="el" href="in6_2_socket_address_8cpp_source.html#l00132">net::in6::SocketAddress::toString()</a>, <a class="el" href="l2_2_socket_address_8cpp_source.html#l00072">net::l2::SocketAddress::toString()</a>, and <a class="el" href="rc_2_socket_address_8cpp_source.html#l00072">net::rc::SocketAddress::toString()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0e94052d485636fc9f18c21009026577_icgraph.svg" width="1436" height="1142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad394fad44bd6c2a82604abba63224a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad394fad44bd6c2a82604abba63224a92">&#9670;&nbsp;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00275">275</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                                               {</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a>(str));</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00239">ltrim()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00257">rtrim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03748">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09041">CLI::ConfigBase::from_config()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06775">CLI::App::parse()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00490">split_up()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00285">trim_copy()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ad394fad44bd6c2a82604abba63224a92_cgraph.svg" width="308" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ad394fad44bd6c2a82604abba63224a92_icgraph.svg" width="567" height="236"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a42ffd53b391fe1eebc540f26c8825692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ffd53b391fe1eebc540f26c8825692">&#9670;&nbsp;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00280">280</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                                                                       {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a>(str, filter), filter);</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00239">ltrim()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00257">rtrim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03925">split_program_name()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a42ffd53b391fe1eebc540f26c8825692_cgraph.svg" width="308" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a42ffd53b391fe1eebc540f26c8825692_icgraph.svg" width="476" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5c7b00a328b3b2da564794081646c251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7b00a328b3b2da564794081646c251">&#9670;&nbsp;</a></span>trim_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of the string and then trim it. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00285">285</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                                                         {</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            std::string s = str;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(s);</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00275">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09041">CLI::ConfigBase::from_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a5c7b00a328b3b2da564794081646c251_cgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a5c7b00a328b3b2da564794081646c251_icgraph.svg" width="382" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a09bd3735d1104a453e5376a43140d5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bd3735d1104a453e5376a43140d5a8">&#9670;&nbsp;</a></span>trim_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of the string and then trim it, any filter string can be used (any char in string is filtered) </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00318">318</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                                                                                  {</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            std::string s = str;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(s, filter);</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00275">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l02553">split_names()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a09bd3735d1104a453e5376a43140d5a8_cgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a09bd3735d1104a453e5376a43140d5a8_icgraph.svg" width="754" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af643ce5d039d1c94f85ca05591501085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643ce5d039d1c94f85ca05591501085">&#9670;&nbsp;</a></span>tuple_type_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;I == <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type CLI::detail::tuple_type_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0 if the index &gt; tuple size </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01388">1388</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;                                                                                                 {</div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af5d45f7af2004b701e37af90df4c031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d45f7af2004b701e37af90df4c031b">&#9670;&nbsp;</a></span>type_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; I&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type <a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a>&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + <a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt;T, I + 1&gt;); } template &lt;typename T&gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt;T, 0&gt;)}; }; template &lt;typename T&gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value ? <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> : <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value}; }; template &lt;typename T, typename Enable = void&gt; struct type_count_min { static const int value{0}; }; template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value}; }; template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{1}; }; template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt;typename T::value_type&gt;::value}; }; template &lt;typename T, std::size_t I&gt; constexpr typename std::enable_if&lt;I == <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type tuple_type_size_min() { return 0; } template &lt;typename T, std::size_t I&gt; constexpr typename std::enable_if &lt; I&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type tuple_type_size_min() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + tuple_type_size_min&lt;T, I + 1&gt;); } template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{tuple_type_size_min&lt;T, 0&gt;)}; }; template &lt;typename T&gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value ? ((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value &lt; <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>) ? <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value : 0) : type_count_min&lt;T&gt;::value}; }; template &lt;typename T, typename Enable = void&gt; struct expected_count { static const int value{0}; }; template &lt;typename T&gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{1}; }; template &lt;typename T&gt; struct expected_count&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>}; }; template &lt;typename T&gt; struct expected_count&lt;T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{expected_count&lt;typename T::value_type&gt;::value}; }; enum class object_category : int { char_value = 1, integral_value = 2, unsigned_integral = 4, enumeration = 6, boolean_value = 8, floating_point = 10, number_constructible = 12, double_constructible = 14, integer_constructible = 16, string_assignable = 23, string_constructible = 24, other = 45, wrapper_value = 50, complex_number = 60, tuple_value = 70, container_value = 80, }; template &lt;typename T, typename Enable = void&gt; struct classify_object { static constexpr object_category value{object_category::other}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, char&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::integral_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, char&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::unsigned_integral}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_same&lt;T, char&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::char_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::boolean_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::floating_point}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; std::is_assignable&lt;T&amp;, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::string_assignable}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T&amp;, std::string&gt;::value &amp;&amp; (<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1) &amp;&amp; std::is_constructible&lt;T, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::string_constructible}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::enumeration}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::complex_number}; }; template &lt;typename T&gt; struct uncommon_type { using type = typename std::conditional&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T&amp;, std::string&gt;::value &amp;&amp; !std::is_constructible&lt;T, std::string&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value, std::true_type, std::false_type&gt;::type; static constexpr bool value = type::value; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;(!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; uncommon_type&lt;T&gt;::value)&gt;::type&gt; { static constexpr object_category value{object_category::wrapper_value}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::number_constructible}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::integer_constructible}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::double_constructible}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; ((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value &gt;= 2 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value) || (uncommon_type&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value))&gt;::type&gt; { static constexpr object_category value{object_category::tuple_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::container_value}; }; template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::char_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;CHAR&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::integral_value || classify_object&lt;T&gt;::value == object_category::integer_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;INT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::unsigned_integral, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;UINT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::floating_point || classify_object&lt;T&gt;::value == object_category::number_constructible || classify_object&lt;T&gt;::value == object_category::double_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;FLOAT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::enumeration, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;ENUM&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::boolean_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;BOOLEAN&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::complex_number, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;COMPLEX&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value &gt;= object_category::string_assignable &amp;&amp; classify_object&lt;T&gt;::value &lt;= object_category::other, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;TEXT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value &gt;= 2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; std::string type_name(); template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::container_value || classify_object&lt;T&gt;::value == object_category::wrapper_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; std::string type_name(); template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value == 1, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; inline std::string type_name() { return type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;0, T&gt;::type&gt;::type&gt;); } template &lt;typename T, std::size_t I&gt; inline typename std::enable_if&lt;I == <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, std::string&gt;::type tuple_name() { return std::string{}; } template &lt;typename T, std::size_t I&gt; inline typename std::enable_if&lt;(I &lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value), std::string&gt;::type tuple_name() { std::string str = std::string(type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::type&gt;)) + ',' + tuple_name&lt;T, I + 1&gt;); <a class="el" href="instrumentation_8cpp.html#ac37cec2090666222861a77657149ef94">if</a> (str.back() == ',') str.pop_back(); return str; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value &gt;= 2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; &gt; std::string CLI::detail::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively generate the tuple type name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01748">1748</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;                                     {</div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;            <span class="keyword">auto</span> tname = std::string(1, <span class="charliteral">&#39;[&#39;</span>) + tuple_name&lt;T, 0&gt;();</div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;            tname.push_back(<span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;            <span class="keywordflow">return</span> tname;</div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a397d777acde370a61fdfc1022a97508b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397d777acde370a61fdfc1022a97508b">&#9670;&nbsp;</a></span>type_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type name for a type that has a value_type member </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01759">1759</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;                                     {</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;            <span class="keywordflow">return</span> type_name&lt;typename T::value_type&gt;();</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac75f9ea4aa9649b9b3890bdcbc64b75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75f9ea4aa9649b9b3890bdcbc64b75a">&#9670;&nbsp;</a></span>valid_alias_name_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_alias_name_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify an app name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00387">387</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                                                                  {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string badChars(std::string(<span class="stringliteral">&quot;\n&quot;</span>) + <span class="charliteral">&#39;\0&#39;</span>);</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            <span class="keywordflow">return</span> (str.find_first_of(badChars) == std::string::npos);</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06495">CLI::App::add_option_group()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05926">CLI::App::alias()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l04214">CLI::OptionBase&lt; CRTP &gt;::group()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac75f9ea4aa9649b9b3890bdcbc64b75a_icgraph.svg" width="378" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3a05d1129df69e88135e178137b1fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a05d1129df69e88135e178137b1fd89">&#9670;&nbsp;</a></span>valid_first_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_first_char </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify the first character of an option</p><ul>
<li>is a trigger character, ! has special meaning and new lines would just be annoying to deal with </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00361">361</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                                   {</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;            <span class="keywordflow">return</span> ((c != <span class="charliteral">&#39;-&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39;!&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39; &#39;</span>) &amp;&amp; c != <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06512">CLI::App::add_subcommand()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02593">get_names()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02521">split_long()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02511">split_short()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02537">split_windows_style()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00375">valid_name_string()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a3a05d1129df69e88135e178137b1fd89_icgraph.svg" width="1079" height="494"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a841371d5dbb0a52f453de4cc1d00cc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841371d5dbb0a52f453de4cc1d00cc51">&#9670;&nbsp;</a></span>valid_later_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_later_char </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify following characters of an option. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00367">367</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                                   {</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;            <span class="comment">// = and : are value separators, { has special meaning for option defaults,</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;            <span class="comment">// and \n would just be annoying to deal with in many places allowing space here has too much potential for</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;            <span class="comment">// inadvertent entry errors and bugs</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;            <span class="keywordflow">return</span> ((c != <span class="charliteral">&#39;=&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39;:&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39;{&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39; &#39;</span>) &amp;&amp; c != <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06512">CLI::App::add_subcommand()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00375">valid_name_string()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a841371d5dbb0a52f453de4cc1d00cc51_icgraph.svg" width="1047" height="290"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4274628d24f9e3fbc719284f1db263b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274628d24f9e3fbc719284f1db263b8">&#9670;&nbsp;</a></span>valid_name_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_name_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify an option/subcommand name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00375">375</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                                                            {</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            <span class="keywordflow">if</span> (str.empty() || !<a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(str[0])) {</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            }</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            <span class="keyword">auto</span> e = str.end();</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> c = str.begin() + 1; c != e; ++c)</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">valid_later_char</a>(*c))</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a841371d5dbb0a52f453de4cc1d00cc51"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">CLI::detail::valid_later_char</a></div><div class="ttdeci">bool valid_later_char(T c)</div><div class="ttdoc">Verify following characters of an option.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00367">CLI11.hpp:367</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00361">valid_first_char()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00367">valid_later_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06512">CLI::App::add_subcommand()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l02593">get_names()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a4274628d24f9e3fbc719284f1db263b8_cgraph.svg" width="312" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a4274628d24f9e3fbc719284f1db263b8_icgraph.svg" width="872" height="283"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9a74f119a795b25c40db74ffa21d3c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74f119a795b25c40db74ffa21d3c2d">&#9670;&nbsp;</a></span>value_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a string as a convertible value for arithmetic types </p>
<p>get a string as a convertible value for enumerations </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01290">1290</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;                                               {</div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">std::to_string</a>(value);</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01244">to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03641">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03496">CLI::IsMember::IsMember()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03575">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9a74f119a795b25c40db74ffa21d3c2d_cgraph.svg" width="342" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9a74f119a795b25c40db74ffa21d3c2d_icgraph.svg" width="406" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a130e048f492ea4619246e2f4cabaf4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130e048f492ea4619246e2f4cabaf4ac">&#9670;&nbsp;</a></span>value_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(value)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for other types just use the regular to_string function </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01300">1300</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;                                                                        {</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">to_string</a>(value);</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01244">to_string()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a130e048f492ea4619246e2f4cabaf4ac_cgraph.svg" width="342" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a01c35a876e2917ffdc1ee618e0c06619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c35a876e2917ffdc1ee618e0c06619">&#9670;&nbsp;</a></span>dummy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a> CLI::detail::dummy = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An instance to use in EnableIf. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00950">950</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>

</div>
</div>
<a id="a99abe3824b1f1bea457ad0ae635f5c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99abe3824b1f1bea457ad0ae635f5c51">&#9670;&nbsp;</a></span>expected_max_vector_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int CLI::detail::expected_max_vector_size {1 &lt;&lt; 29}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>a constant defining an expected max vector size defined to be a big number that could be multiplied by 4 and not produce overflow for some expected uses </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00171">171</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08350">CLI::App::_parse_arg()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l07525">CLI::App::_validate()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04530">CLI::Option::expected()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04935">CLI::Option::get_items_expected_max()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09484">CLI::Formatter::make_option_opts()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09523">CLI::Formatter::make_option_usage()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04822">CLI::Option::multi_option_policy()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l05300">CLI::Option::type_size()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_c_l_i.html">CLI</a></li><li class="navelem"><a class="el" href="namespace_c_l_i_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Sun Jul 24 2022 13:11:10 for snode.c by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
