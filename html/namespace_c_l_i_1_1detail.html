<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snode.c: CLI::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">snode.c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_c_l_i_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CLI::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1element__type.html">element_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">not a pointer  <a href="struct_c_l_i_1_1detail_1_1element__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1element__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__copyablcf4068753293666f52fa2143458d7e20.html">element_type&lt; T, typename std::enable_if&lt; is_copyable_ptr&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1element__value__type.html">element_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1pair__adaptor.html">pair_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for set-like structure: This just wraps a normal container in a few utilities that do almost nothing.  <a href="struct_c_l_i_1_1detail_1_1pair__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1pair__adaptor_3_01_t_00_01conditional__t_3_01false_00_01void__t_3_01ty57376c4a6f008b828f6707df132586d8.html">pair_adaptor&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type::first_type, typename T::value_type::second_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__istreamable.html">is_istreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for input streamability.  <a href="class_c_l_i_1_1detail_1_1is__istreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for complex.  <a href="class_c_l_i_1_1detail_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container_3_01_t_00_01conditional__t_3_01false_00_01void_9711c92f16061f5742bb50eefb1b0c0c.html">is_mutable_container&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type, decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().clear()), decltype(std::declval&lt; T &gt;().insert(std::declval&lt; decltype(std::declval&lt; T &gt;().end())&gt;(), std::declval&lt; const typename T::value_type &amp; &gt;()))&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__readable__container.html">is_readable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__readable__container_3_01_t_00_01conditional__t_3_01false_00_01void1b163ef1438ddc3089d5e11b3b2b1293.html">is_readable_container&lt; T, conditional_t&lt; false, void_t&lt; decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().begin())&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper_3_01_t_00_01conditional__t_3_01false_00_01void__t_3_01type256f69b9a9ada1608beb2e1e7b0f6f4c.html">is_wrapper&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1wrapped__type.html">wrapped_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to get the underlying value type if it exists or use a default  <a href="struct_c_l_i_1_1detail_1_1wrapped__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1wrapped__type_3_01_t_00_01def_00_01typename_01std_1_1enable__if_3_01isa724b5b3d1f263241cafc27a49bae246.html">wrapped_type&lt; T, def, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="struct_c_l_i_1_1detail_1_1wrapped__type_3_01_t_00_01def_00_01typename_01std_1_1enable__if_3_01isa724b5b3d1f263241cafc27a49bae246.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="struct_c_l_i_1_1detail_1_1type__count__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_9is__tupl1d95856913595d9d18df1e9b7db10a2c.html">type_count_base&lt; T, typename std::enable_if&lt;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_9is__tupl1d95856913595d9d18df1e9b7db10a2c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__tup573c8f6a452dc2b871d7cd3189dda714.html">type_count_base&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the base tuple size  <a href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__tup573c8f6a452dc2b871d7cd3189dda714.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mut25537d1dbe2209c0fb1d9a95e46a36a7.html">type_count_base&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type count base for containers is the <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html" title="This will only trigger for actual void type.">type_count_base</a> of the individual element.  <a href="struct_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mut25537d1dbe2209c0fb1d9a95e46a36a7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of overloads to get the type size of an object.  <a href="struct_c_l_i_1_1detail_1_1subtype__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declare the <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html" title="forward declare the subtype_count_min structure">subtype_count_min</a> structure  <a href="struct_c_l_i_1_1detail_1_1subtype__count__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="struct_c_l_i_1_1detail_1_1type__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_b01f5ffbc1be4715e41384ef05a4c2a6.html">type_count&lt; T, typename std::enable_if&lt;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_b01f5ffbc1be4715e41384ef05a4c2a6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__complex_31fac009dcf70627e04f80462c5d88ca8.html">type_count&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for complex since it sometimes looks like a wrapper.  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__complex_31fac009dcf70627e04f80462c5d88ca8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mutable__cb200eb27fab347649b083951e77032e.html">type_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size of types that are wrappers,except complex and tuples(which can also be wrappers sometimes)  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__mutable__cb200eb27fab347649b083951e77032e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__wrapper_39a4e337a2aa393bb8556b7ab15846b8b.html">type_count&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size of types that are wrappers,except containers complex and tuples(which can also be wrappers sometimes)  <a href="struct_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_01is__wrapper_39a4e337a2aa393bb8556b7ab15846b8b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_existing_file_validator.html">ExistingFileValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing file (returns error message if check fails)  <a href="class_c_l_i_1_1detail_1_1_existing_file_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_existing_directory_validator.html">ExistingDirectoryValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing directory (returns error message if check fails)  <a href="class_c_l_i_1_1detail_1_1_existing_directory_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_existing_path_validator.html">ExistingPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing path.  <a href="class_c_l_i_1_1detail_1_1_existing_path_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_nonexistent_path_validator.html">NonexistentPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an non-existing path.  <a href="class_c_l_i_1_1detail_1_1_nonexistent_path_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_l_i_1_1detail_1_1_i_p_v4_validator.html">IPV4Validator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the given string is a legal ipv4 address.  <a href="class_c_l_i_1_1detail_1_1_i_p_v4_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1has__find.html">has_find</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_l_i_1_1detail_1_1_app_friend.html">AppFriend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is simply to allow tests access to <a class="el" href="class_c_l_i_1_1_app.html" title="Creates a command line program, with very few defaults.">App</a>'s protected functions.  <a href="struct_c_l_i_1_1detail_1_1_app_friend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af27dda5da343e609526e3dacf435b1c6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a> </td></tr>
<tr class="memdesc:af27dda5da343e609526e3dacf435b1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple empty scoped class.  <a href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">More...</a><br /></td></tr>
<tr class="separator:af27dda5da343e609526e3dacf435b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a> { <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928">nonexistent</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">file</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20">directory</a>
 }</td></tr>
<tr class="memdesc:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_c_l_i.html">CLI</a> enumeration of different file types.  <a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">More...</a><br /></td></tr>
<tr class="separator:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba10771e3ff645fe1305be4cae517573"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573">Classifier</a> { <br />
&#160;&#160;<a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6">POSITIONAL_MARK</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77">SHORT</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3">LONG</a>
, <br />
&#160;&#160;<a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda">WINDOWS_STYLE</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7">SUBCOMMAND</a>
, <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00">SUBCOMMAND_TERMINATOR</a>
<br />
 }</td></tr>
<tr class="separator:aba10771e3ff645fe1305be4cae517573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string by a delim.  <a href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">More...</a><br /></td></tr>
<tr class="separator:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ab351f13ec104e2cba19ec6baf4a552f6">join</a> (const T &amp;v, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:ab351f13ec104e2cba19ec6baf4a552f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to join a string.  <a href="namespace_c_l_i_1_1detail.html#ab351f13ec104e2cba19ec6baf4a552f6">More...</a><br /></td></tr>
<tr class="separator:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8597debec6c8bc164109538253ffc623"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callable , typename  = typename std::enable_if&lt;!std::is_constructible&lt;std::string, Callable&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8597debec6c8bc164109538253ffc623"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">join</a> (const T &amp;v, Callable func, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:a8597debec6c8bc164109538253ffc623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to join a string from processed elements.  <a href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">More...</a><br /></td></tr>
<tr class="separator:a8597debec6c8bc164109538253ffc623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74b520ee1011d38fde77f907ddfea40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af74b520ee1011d38fde77f907ddfea40"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af74b520ee1011d38fde77f907ddfea40">rjoin</a> (const T &amp;v, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:af74b520ee1011d38fde77f907ddfea40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a string in reverse order.  <a href="namespace_c_l_i_1_1detail.html#af74b520ee1011d38fde77f907ddfea40">More...</a><br /></td></tr>
<tr class="separator:af74b520ee1011d38fde77f907ddfea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae078b951ab0e11b84dffe200d0049c"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#acae078b951ab0e11b84dffe200d0049c">ltrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:acae078b951ab0e11b84dffe200d0049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from left of string.  <a href="namespace_c_l_i_1_1detail.html#acae078b951ab0e11b84dffe200d0049c">More...</a><br /></td></tr>
<tr class="separator:acae078b951ab0e11b84dffe200d0049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb44de7c57bbb1384f737dc2f04265b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a> (std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a2cb44de7c57bbb1384f737dc2f04265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from left of string.  <a href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">More...</a><br /></td></tr>
<tr class="separator:a2cb44de7c57bbb1384f737dc2f04265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9338ae7c45f34f8240a31325d8d71c"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aed9338ae7c45f34f8240a31325d8d71c">rtrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:aed9338ae7c45f34f8240a31325d8d71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from right of string.  <a href="namespace_c_l_i_1_1detail.html#aed9338ae7c45f34f8240a31325d8d71c">More...</a><br /></td></tr>
<tr class="separator:aed9338ae7c45f34f8240a31325d8d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27306fb661edc7a7017a09a0e9ee7b18"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a> (std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a27306fb661edc7a7017a09a0e9ee7b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from right of string.  <a href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">More...</a><br /></td></tr>
<tr class="separator:a27306fb661edc7a7017a09a0e9ee7b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad394fad44bd6c2a82604abba63224a92"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ad394fad44bd6c2a82604abba63224a92">trim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ad394fad44bd6c2a82604abba63224a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from string.  <a href="namespace_c_l_i_1_1detail.html#ad394fad44bd6c2a82604abba63224a92">More...</a><br /></td></tr>
<tr class="separator:ad394fad44bd6c2a82604abba63224a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ffd53b391fe1eebc540f26c8825692"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a> (std::string &amp;str, const std::string filter)</td></tr>
<tr class="memdesc:a42ffd53b391fe1eebc540f26c8825692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from string.  <a href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">More...</a><br /></td></tr>
<tr class="separator:a42ffd53b391fe1eebc540f26c8825692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b00a328b3b2da564794081646c251"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a5c7b00a328b3b2da564794081646c251">trim_copy</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a5c7b00a328b3b2da564794081646c251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of the string and then trim it.  <a href="namespace_c_l_i_1_1detail.html#a5c7b00a328b3b2da564794081646c251">More...</a><br /></td></tr>
<tr class="separator:a5c7b00a328b3b2da564794081646c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242fa1bec3353c591a730efc6307f3ea"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">remove_quotes</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a242fa1bec3353c591a730efc6307f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove quotes at the front and back of a string either '"' or '\''  <a href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">More...</a><br /></td></tr>
<tr class="separator:a242fa1bec3353c591a730efc6307f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f983b056b683129ec20e53d8c6141ab"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a6f983b056b683129ec20e53d8c6141ab">fix_newlines</a> (const std::string &amp;leader, std::string input)</td></tr>
<tr class="separator:a6f983b056b683129ec20e53d8c6141ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bd3735d1104a453e5376a43140d5a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">trim_copy</a> (const std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a09bd3735d1104a453e5376a43140d5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of the string and then trim it, any filter string can be used (any char in string is filtered)  <a href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">More...</a><br /></td></tr>
<tr class="separator:a09bd3735d1104a453e5376a43140d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569874f0c04636b7f0e63f40caf6e170"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a569874f0c04636b7f0e63f40caf6e170">format_help</a> (std::ostream &amp;out, std::string name, const std::string &amp;description, std::size_t wid)</td></tr>
<tr class="memdesc:a569874f0c04636b7f0e63f40caf6e170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a two part "help" string.  <a href="namespace_c_l_i_1_1detail.html#a569874f0c04636b7f0e63f40caf6e170">More...</a><br /></td></tr>
<tr class="separator:a569874f0c04636b7f0e63f40caf6e170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af375283ee4242348cd6d3df419d7bc62"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af375283ee4242348cd6d3df419d7bc62">format_aliases</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;aliases, std::size_t wid)</td></tr>
<tr class="memdesc:af375283ee4242348cd6d3df419d7bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print subcommand aliases.  <a href="namespace_c_l_i_1_1detail.html#af375283ee4242348cd6d3df419d7bc62">More...</a><br /></td></tr>
<tr class="separator:af375283ee4242348cd6d3df419d7bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05d1129df69e88135e178137b1fd89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a05d1129df69e88135e178137b1fd89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a> (T c)</td></tr>
<tr class="separator:a3a05d1129df69e88135e178137b1fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">valid_later_char</a> (T c)</td></tr>
<tr class="memdesc:a841371d5dbb0a52f453de4cc1d00cc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify following characters of an option.  <a href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">More...</a><br /></td></tr>
<tr class="separator:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274628d24f9e3fbc719284f1db263b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">valid_name_string</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a4274628d24f9e3fbc719284f1db263b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an option/subcommand name.  <a href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">More...</a><br /></td></tr>
<tr class="separator:a4274628d24f9e3fbc719284f1db263b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f9ea4aa9649b9b3890bdcbc64b75a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac75f9ea4aa9649b9b3890bdcbc64b75a">valid_alias_name_string</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ac75f9ea4aa9649b9b3890bdcbc64b75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an app name.  <a href="namespace_c_l_i_1_1detail.html#ac75f9ea4aa9649b9b3890bdcbc64b75a">More...</a><br /></td></tr>
<tr class="separator:ac75f9ea4aa9649b9b3890bdcbc64b75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b46b96102830769cc02952392e782f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a53b46b96102830769cc02952392e782f">is_separator</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a53b46b96102830769cc02952392e782f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a string is a container segment separator (empty or "%%")  <a href="namespace_c_l_i_1_1detail.html#a53b46b96102830769cc02952392e782f">More...</a><br /></td></tr>
<tr class="separator:a53b46b96102830769cc02952392e782f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89ce22647a9f697b800d9c47b9d956f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac89ce22647a9f697b800d9c47b9d956f">isalpha</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ac89ce22647a9f697b800d9c47b9d956f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that str consists of letters only.  <a href="namespace_c_l_i_1_1detail.html#ac89ce22647a9f697b800d9c47b9d956f">More...</a><br /></td></tr>
<tr class="separator:ac89ce22647a9f697b800d9c47b9d956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83709ec148057ec53df4383645727e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">to_lower</a> (std::string str)</td></tr>
<tr class="memdesc:ae83709ec148057ec53df4383645727e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a lower case version of a string.  <a href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">More...</a><br /></td></tr>
<tr class="separator:ae83709ec148057ec53df4383645727e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5359a7a0e33366a12e15523b100f591a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">remove_underscore</a> (std::string str)</td></tr>
<tr class="memdesc:a5359a7a0e33366a12e15523b100f591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove underscores from a string  <a href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">More...</a><br /></td></tr>
<tr class="separator:a5359a7a0e33366a12e15523b100f591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b1977d7375250cc57d90723cf1554"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">find_and_replace</a> (std::string str, std::string from, std::string to)</td></tr>
<tr class="memdesc:ab39b1977d7375250cc57d90723cf1554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and replace a substring with another substring.  <a href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">More...</a><br /></td></tr>
<tr class="separator:ab39b1977d7375250cc57d90723cf1554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89da9fa11d234a8bf504d6ec85133cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ae89da9fa11d234a8bf504d6ec85133cc">has_default_flag_values</a> (const std::string &amp;flags)</td></tr>
<tr class="memdesc:ae89da9fa11d234a8bf504d6ec85133cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the flag definitions has possible false flags  <a href="namespace_c_l_i_1_1detail.html#ae89da9fa11d234a8bf504d6ec85133cc">More...</a><br /></td></tr>
<tr class="separator:ae89da9fa11d234a8bf504d6ec85133cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b9afbe8a438ab30291d35f1f24c87c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a73b9afbe8a438ab30291d35f1f24c87c">remove_default_flag_values</a> (std::string &amp;flags)</td></tr>
<tr class="separator:a73b9afbe8a438ab30291d35f1f24c87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a356b9c9cc904af2b0a918fd55e86cd9c">find_member</a> (std::string name, const std::vector&lt; std::string &gt; names, bool <a class="el" href="namespace_c_l_i.html#a0c52326d2681814c22aa1a93ce43375e">ignore_case</a>=false, bool <a class="el" href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">ignore_underscore</a>=false)</td></tr>
<tr class="memdesc:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string is a member of a list of strings and optionally ignore case or ignore underscores.  <a href="namespace_c_l_i_1_1detail.html#a356b9c9cc904af2b0a918fd55e86cd9c">More...</a><br /></td></tr>
<tr class="separator:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fbb1952b19838d8377ab714dc33e4c"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:a59fbb1952b19838d8377ab714dc33e4c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a59fbb1952b19838d8377ab714dc33e4c">find_and_modify</a> (std::string str, std::string trigger, Callable modify)</td></tr>
<tr class="separator:a59fbb1952b19838d8377ab714dc33e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6e8a6354d9645d3da614f6734573a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aad6e8a6354d9645d3da614f6734573a8">split_up</a> (std::string str, char delimiter='\0')</td></tr>
<tr class="separator:aad6e8a6354d9645d3da614f6734573a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24078bb1f5e51808a5001a47d2b40c3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac24078bb1f5e51808a5001a47d2b40c3">escape_detect</a> (std::string &amp;str, std::size_t offset)</td></tr>
<tr class="separator:ac24078bb1f5e51808a5001a47d2b40c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af694bfd321727b1a8c5d7dab22d52617"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af694bfd321727b1a8c5d7dab22d52617">add_quotes_if_needed</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:af694bfd321727b1a8c5d7dab22d52617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add quotes if the string contains spaces.  <a href="namespace_c_l_i_1_1detail.html#af694bfd321727b1a8c5d7dab22d52617">More...</a><br /></td></tr>
<tr class="separator:af694bfd321727b1a8c5d7dab22d52617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">from_stream</a> (const std::string &amp;istring, T &amp;obj)</td></tr>
<tr class="memdesc:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated operation to get a value from a stream.  <a href="namespace_c_l_i_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">More...</a><br /></td></tr>
<tr class="separator:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a> (T &amp;&amp;value) -&gt; decltype(std::forward&lt; T &gt;(value))</td></tr>
<tr class="memdesc:a0e94052d485636fc9f18c21009026577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (directly forward if this can become a string)  <a href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">More...</a><br /></td></tr>
<tr class="separator:a0e94052d485636fc9f18c21009026577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">to_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4e5965e3013bad7369e985e2f2fd42f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from the object.  <a href="namespace_c_l_i_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">More...</a><br /></td></tr>
<tr class="separator:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">to_string</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a9c070858740ce15aaecb1c5f04e21a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (streaming must be supported for that type)  <a href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">More...</a><br /></td></tr>
<tr class="separator:a9c070858740ce15aaecb1c5f04e21a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">checked_to_string</a> (T &amp;&amp;value) -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(std::forward&lt; T &gt;(value)))</td></tr>
<tr class="memdesc:a1bcb244a7701fc68da3a863b58daf615"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespace_c_l_i_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">More...</a><br /></td></tr>
<tr class="separator:a1bcb244a7701fc68da3a863b58daf615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">checked_to_string</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:ae396058c9ea28259db0c05376bf9c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespace_c_l_i_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">More...</a><br /></td></tr>
<tr class="separator:ae396058c9ea28259db0c05376bf9c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">value_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9a74f119a795b25c40db74ffa21d3c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string as a convertible value for arithmetic types  <a href="namespace_c_l_i_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">More...</a><br /></td></tr>
<tr class="separator:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">value_string</a> (const T &amp;value) -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(value))</td></tr>
<tr class="memdesc:a130e048f492ea4619246e2f4cabaf4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">for other types just use the regular to_string function  <a href="namespace_c_l_i_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">More...</a><br /></td></tr>
<tr class="separator:a130e048f492ea4619246e2f4cabaf4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I==<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a> ()</td></tr>
<tr class="memdesc:af643ce5d039d1c94f85ca05591501085"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 if the index &gt; tuple size  <a href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">More...</a><br /></td></tr>
<tr class="separator:af643ce5d039d1c94f85ca05591501085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d45f7af2004b701e37af90df4c031b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:af5d45f7af2004b701e37af90df4c031b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type <a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+<a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt; T, I+1 &gt;);} template&lt; typename T &gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt; T, 0 &gt;)};};template&lt; typename T &gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ? <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> :<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct type_count_min { static const int value{0};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename T::value_type &gt;::value};};template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I==<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return 0;} template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;);} template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size_min&lt; T, 0 &gt;)};};template&lt; typename T &gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ?((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value&lt; <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>) ? <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct expected_count { static const int value{0};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_count&lt; typename T::value_type &gt;::value};};enum class object_category :int { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80, };template&lt; typename T, typename Enable=void &gt; struct classify_object { static constexpr object_category value{object_category::other};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integral_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::unsigned_integral};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, char &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::char_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::boolean_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::floating_point};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_assignable};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::enumeration};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::complex_number};};template&lt; typename T &gt; struct uncommon_type { using type=typename std::conditional&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type;static constexpr bool value=type::value;};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt;(!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value{object_category::wrapper_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::number_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integer_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::double_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value &gt;=2 &amp;&amp;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, double &gt;::value &amp;&amp;!<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, int &gt;::value))&gt;::type &gt; { static constexpr object_category value{object_category::tuple_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::container_value};};template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::char_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;CHAR&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::integer_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;INT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;UINT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::floating_point||classify_object&lt; T &gt;::value==object_category::number_constructible||classify_object&lt; T &gt;::value==object_category::double_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;FLOAT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::enumeration, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;ENUM&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;BOOLEAN&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::complex_number, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;COMPLEX&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp;classify_object&lt; T &gt;::value&lt;=object_category::other, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; constexpr const char *type_name() { return &quot;TEXT&quot;;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; std::string type_name();template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; std::string type_name();template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value==1, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt; inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;);} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt; I==<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string{};} template&lt; typename T, std::size_t I &gt; inline typename std::enable_if&lt;(I&lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value), std::string &gt;::type tuple_name() { std::string str=std::string(type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;))+','+tuple_name&lt; T, I+1 &gt;);<a class="el" href="instrumentation_8cpp.html#ac37cec2090666222861a77657149ef94">if</a>(str.back()==',') str.pop_back();return str;} template&lt; typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt; &gt; std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af5d45f7af2004b701e37af90df4c031b">type_name</a> ()</td></tr>
<tr class="memdesc:af5d45f7af2004b701e37af90df4c031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively generate the tuple type name.  <a href="namespace_c_l_i_1_1detail.html#af5d45f7af2004b701e37af90df4c031b">More...</a><br /></td></tr>
<tr class="separator:af5d45f7af2004b701e37af90df4c031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; </td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a397d777acde370a61fdfc1022a97508b">type_name</a> ()</td></tr>
<tr class="memdesc:a397d777acde370a61fdfc1022a97508b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type name for a type that has a value_type member  <a href="namespace_c_l_i_1_1detail.html#a397d777acde370a61fdfc1022a97508b">More...</a><br /></td></tr>
<tr class="separator:a397d777acde370a61fdfc1022a97508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">integral_conversion</a> (const std::string &amp;input, T &amp;output) noexcept</td></tr>
<tr class="memdesc:af6685ecdb07b40a316035bb4af9b02e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an unsigned integral.  <a href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">More...</a><br /></td></tr>
<tr class="separator:af6685ecdb07b40a316035bb4af9b02e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45abf683b881127298aa28b3c4e6cf5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">to_flag_value</a> (std::string val)</td></tr>
<tr class="memdesc:af45abf683b881127298aa28b3c4e6cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a flag into an integer value typically binary flags.  <a href="namespace_c_l_i_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">More...</a><br /></td></tr>
<tr class="separator:af45abf683b881127298aa28b3c4e6cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">lexical_cast</a> (const std::string &amp;input, T &amp;output)</td></tr>
<tr class="memdesc:af286727de86fce444325681379e2c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer conversion.  <a href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">More...</a><br /></td></tr>
<tr class="separator:af286727de86fce444325681379e2c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplParams" colspan="2">template&lt;typename AssignTo , typename ConvertTo , enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">lexical_assign</a> (const std::string &amp;input, AssignTo &amp;output)</td></tr>
<tr class="memdesc:ab6647281bf64bba7b07737297ae1895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value through lexical cast operations.  <a href="namespace_c_l_i_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">More...</a><br /></td></tr>
<tr class="separator:ab6647281bf64bba7b07737297ae1895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6f215bcb727ff49f126ac3e1a13e40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a1e6f215bcb727ff49f126ac3e1a13e40">split_short</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;rest)</td></tr>
<tr class="separator:a1e6f215bcb727ff49f126ac3e1a13e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de15b0ba0d12c9170d15693477808ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0de15b0ba0d12c9170d15693477808ed">split_long</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:a0de15b0ba0d12c9170d15693477808ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbd2b5b93afe2f10427dd6e32639b0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aadbd2b5b93afe2f10427dd6e32639b0c">split_windows_style</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:aadbd2b5b93afe2f10427dd6e32639b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf817a10b92907070c02b752c37aa09d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#abf817a10b92907070c02b752c37aa09d">split_names</a> (std::string current)</td></tr>
<tr class="separator:abf817a10b92907070c02b752c37aa09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a49ea386ace9f320e1ba59d7eba49b7cf">get_default_flag_values</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract default flag values either {def} or starting with a !  <a href="namespace_c_l_i_1_1detail.html#a49ea386ace9f320e1ba59d7eba49b7cf">More...</a><br /></td></tr>
<tr class="separator:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ae97bbbd9e400bd94b316dd865cb66"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a23ae97bbbd9e400bd94b316dd865cb66">get_names</a> (const std::vector&lt; std::string &gt; &amp;input)</td></tr>
<tr class="memdesc:a23ae97bbbd9e400bd94b316dd865cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of short names, one of long names, and a single name.  <a href="namespace_c_l_i_1_1detail.html#a23ae97bbbd9e400bd94b316dd865cb66">More...</a><br /></td></tr>
<tr class="separator:a23ae97bbbd9e400bd94b316dd865cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197be0b62b4d4deef0f5cac600a6b759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">check_path</a> (const char *file) noexcept</td></tr>
<tr class="memdesc:a197be0b62b4d4deef0f5cac600a6b759"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type of the path from a file name  <a href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">More...</a><br /></td></tr>
<tr class="separator:a197be0b62b4d4deef0f5cac600a6b759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">smart_deref</a> (T value) -&gt; decltype(*value)</td></tr>
<tr class="separator:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd67b783a1c4441c89f071774ac398b"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:adcd67b783a1c4441c89f071774ac398b"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference&lt; T &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">smart_deref</a> (T &amp;value)</td></tr>
<tr class="separator:adcd67b783a1c4441c89f071774ac398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f66945cfe53b556e4c311f9a88a155"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75f66945cfe53b556e4c311f9a88a155"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a75f66945cfe53b556e4c311f9a88a155">generate_set</a> (const T &amp;set)</td></tr>
<tr class="memdesc:a75f66945cfe53b556e4c311f9a88a155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a set.  <a href="namespace_c_l_i_1_1detail.html#a75f66945cfe53b556e4c311f9a88a155">More...</a><br /></td></tr>
<tr class="separator:a75f66945cfe53b556e4c311f9a88a155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320e031a5eb12297a140d2d6fc73362a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a320e031a5eb12297a140d2d6fc73362a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a320e031a5eb12297a140d2d6fc73362a">generate_map</a> (const T &amp;map, bool key_only=false)</td></tr>
<tr class="memdesc:a320e031a5eb12297a140d2d6fc73362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a map.  <a href="namespace_c_l_i_1_1detail.html#a320e031a5eb12297a140d2d6fc73362a">More...</a><br /></td></tr>
<tr class="separator:a320e031a5eb12297a140d2d6fc73362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b4a0a97c9b07110595765887647385"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V , enable_if_t&lt;!has_find&lt; T, V &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:aa4b4a0a97c9b07110595765887647385"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aa4b4a0a97c9b07110595765887647385">search</a> (const T &amp;set, const V &amp;val) -&gt; std::pair&lt; bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:aa4b4a0a97c9b07110595765887647385"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function.  <a href="namespace_c_l_i_1_1detail.html#aa4b4a0a97c9b07110595765887647385">More...</a><br /></td></tr>
<tr class="separator:aa4b4a0a97c9b07110595765887647385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb81a667288aa66a4576a06b9322092"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:abcb81a667288aa66a4576a06b9322092"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">search</a> (const T &amp;set, const V &amp;val, const std::function&lt; V(V)&gt; &amp;filter_function) -&gt; std::pair&lt; bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:abcb81a667288aa66a4576a06b9322092"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function with a filter function.  <a href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">More...</a><br /></td></tr>
<tr class="separator:abcb81a667288aa66a4576a06b9322092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96583f0b43752f7fa77a6c24dae4802"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac96583f0b43752f7fa77a6c24dae4802"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac96583f0b43752f7fa77a6c24dae4802">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ac96583f0b43752f7fa77a6c24dae4802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on signed numbers.  <a href="namespace_c_l_i_1_1detail.html#ac96583f0b43752f7fa77a6c24dae4802">More...</a><br /></td></tr>
<tr class="separator:ac96583f0b43752f7fa77a6c24dae4802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9da7d60b3b5738079257829c777c9c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9da7d60b3b5738079257829c777c9c7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ad9da7d60b3b5738079257829c777c9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on unsigned numbers.  <a href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">More...</a><br /></td></tr>
<tr class="separator:ad9da7d60b3b5738079257829c777c9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#ac1a57be7d4de9c0552f91b8f16d47aad">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise.  <a href="namespace_c_l_i_1_1detail.html#ac1a57be7d4de9c0552f91b8f16d47aad">More...</a><br /></td></tr>
<tr class="separator:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#aaf8289908c3b0f3fa2cb597f787a06aa">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't equal infinity. Returns false otherwise.  <a href="namespace_c_l_i_1_1detail.html#aaf8289908c3b0f3fa2cb597f787a06aa">More...</a><br /></td></tr>
<tr class="separator:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c9893591d9e9d3d4c9d7282d50b9d2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a33c9893591d9e9d3d4c9d7282d50b9d2">split_program_name</a> (std::string commandline)</td></tr>
<tr class="separator:a33c9893591d9e9d3d4c9d7282d50b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382165480a50710d41e421dd54079a7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a2382165480a50710d41e421dd54079a7">convert_arg_for_ini</a> (const std::string &amp;arg, char stringQuote='&quot;', char characterQuote = '\'') </td></tr>
<tr class="separator:a2382165480a50710d41e421dd54079a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b12b08c7bc02a39431b3da4f123e93d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a0b12b08c7bc02a39431b3da4f123e93d">ini_join</a> (const std::vector&lt; std::string &gt; &amp;args, char sepChar=',', char arrayStart='[', char arrayEnd=']', char stringQuote='&quot;', char characterQuote = '\'') </td></tr>
<tr class="memdesc:a0b12b08c7bc02a39431b3da4f123e93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comma separated join, adds quotes if needed.  <a href="namespace_c_l_i_1_1detail.html#a0b12b08c7bc02a39431b3da4f123e93d">More...</a><br /></td></tr>
<tr class="separator:a0b12b08c7bc02a39431b3da4f123e93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d5b7ba1cbf90d9882ab35c67156469"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a36d5b7ba1cbf90d9882ab35c67156469">generate_parents</a> (const std::string &amp;section, std::string &amp;name, char parentSeparator)</td></tr>
<tr class="separator:a36d5b7ba1cbf90d9882ab35c67156469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c3c6f67c8fef09def5f328856dd154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#af3c3c6f67c8fef09def5f328856dd154">checkParentSegments</a> (std::vector&lt; <a class="el" href="struct_c_l_i_1_1_config_item.html">ConfigItem</a> &gt; &amp;output, const std::string &amp;currentSection, char parentSeparator)</td></tr>
<tr class="memdesc:af3c3c6f67c8fef09def5f328856dd154"><td class="mdescLeft">&#160;</td><td class="mdescRight">assuming non default segments do a check on the close and open of the segments in a configItem structure  <a href="namespace_c_l_i_1_1detail.html#af3c3c6f67c8fef09def5f328856dd154">More...</a><br /></td></tr>
<tr class="separator:af3c3c6f67c8fef09def5f328856dd154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a99abe3824b1f1bea457ad0ae635f5c51"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> {1 &lt;&lt; 29}</td></tr>
<tr class="separator:a99abe3824b1f1bea457ad0ae635f5c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c35a876e2917ffdc1ee618e0c06619"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">dummy</a> = {}</td></tr>
<tr class="memdesc:a01c35a876e2917ffdc1ee618e0c06619"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance to use in EnableIf.  <a href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">More...</a><br /></td></tr>
<tr class="separator:a01c35a876e2917ffdc1ee618e0c06619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aba10771e3ff645fe1305be4cae517573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba10771e3ff645fe1305be4cae517573">&#9670;&nbsp;</a></span>Classifier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573">CLI::detail::Classifier</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6"></a>POSITIONAL_MARK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77"></a>SHORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3"></a>LONG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda"></a>WINDOWS_STYLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7"></a>SUBCOMMAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00"></a>SUBCOMMAND_TERMINATOR&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l05501">5501</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l05501"></a><span class="lineno"> 5501</span>&#160;{ <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693">NONE</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6">POSITIONAL_MARK</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77">SHORT</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3">LONG</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda">WINDOWS_STYLE</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7">SUBCOMMAND</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00">SUBCOMMAND_TERMINATOR</a> };</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda">CLI::detail::Classifier::WINDOWS_STYLE</a></div><div class="ttdeci">@ WINDOWS_STYLE</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6">CLI::detail::Classifier::POSITIONAL_MARK</a></div><div class="ttdeci">@ POSITIONAL_MARK</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77">CLI::detail::Classifier::SHORT</a></div><div class="ttdeci">@ SHORT</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00">CLI::detail::Classifier::SUBCOMMAND_TERMINATOR</a></div><div class="ttdeci">@ SUBCOMMAND_TERMINATOR</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693">CLI::detail::Classifier::NONE</a></div><div class="ttdeci">@ NONE</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3">CLI::detail::Classifier::LONG</a></div><div class="ttdeci">@ LONG</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7">CLI::detail::Classifier::SUBCOMMAND</a></div><div class="ttdeci">@ SUBCOMMAND</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af27dda5da343e609526e3dacf435b1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27dda5da343e609526e3dacf435b1c6">&#9670;&nbsp;</a></span>enabler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">CLI::detail::enabler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple empty scoped class. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00923">923</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;{};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a20a9a67e5f06ba0dc3f2ded2fed16f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a9a67e5f06ba0dc3f2ded2fed16f55">&#9670;&nbsp;</a></span>path_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">CLI::detail::path_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_c_l_i.html">CLI</a> enumeration of different file types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928"></a>nonexistent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac"></a>file&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20"></a>directory&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03012">3012</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03012"></a><span class="lineno"> 3012</span>&#160;{ <a class="code" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928">nonexistent</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">file</a>, <a class="code" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20">directory</a> };</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928">CLI::detail::path_type::nonexistent</a></div><div class="ttdeci">@ nonexistent</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20">CLI::detail::path_type::directory</a></div><div class="ttdeci">@ directory</div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">CLI::detail::path_type::file</a></div><div class="ttdeci">@ file</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af694bfd321727b1a8c5d7dab22d52617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af694bfd321727b1a8c5d7dab22d52617">&#9670;&nbsp;</a></span>add_quotes_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::add_quotes_if_needed </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add quotes if the string contains spaces. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00538">538</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                                                               {</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;            <span class="keywordflow">if</span> ((str.front() != <span class="charliteral">&#39;&quot;&#39;</span> &amp;&amp; str.front() != <span class="charliteral">&#39;\&#39;&#39;</span>) || str.front() != str.back()) {</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                <span class="keywordtype">char</span> quote = str.find(<span class="charliteral">&#39;&quot;&#39;</span>) &lt; str.find(<span class="charliteral">&#39;\&#39;&#39;</span>) ? <span class="charliteral">&#39;\&#39;&#39;</span> : <span class="charliteral">&#39;&quot;&#39;</span>;</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;                <span class="keywordflow">if</span> (str.find(<span class="charliteral">&#39; &#39;</span>) != std::string::npos) {</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                    str.insert(0, 1, quote);</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                    str.append(1, quote);</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                }</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;            }</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a197be0b62b4d4deef0f5cac600a6b759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197be0b62b4d4deef0f5cac600a6b759">&#9670;&nbsp;</a></span>check_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a> CLI::detail::check_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type of the path from a file name </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03041">3041</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;                                                               {</div>
<div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;<span class="preprocessor">#if defined(_MSC_VER)</span></div>
<div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;            <span class="keyword">struct </span>__stat64 buffer;</div>
<div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;            <span class="keywordflow">if</span> (_stat64(file, &amp;buffer) == 0) {</div>
<div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160;                <span class="keywordflow">return</span> ((buffer.st_mode &amp; S_IFDIR) != 0) ? path_type::directory : path_type::file;</div>
<div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;            }</div>
<div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;            <span class="keyword">struct </span>stat buffer;</div>
<div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;            <span class="keywordflow">if</span> (stat(file, &amp;buffer) == 0) {</div>
<div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;                <span class="keywordflow">return</span> ((buffer.st_mode &amp; S_IFDIR) != 0) ? path_type::directory : path_type::file;</div>
<div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160;            }</div>
<div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;            <span class="keywordflow">return</span> path_type::nonexistent;</div>
<div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespace_c_l_i_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">file</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l07559">CLI::App::_process_config_file()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03077">CLI::detail::ExistingDirectoryValidator::ExistingDirectoryValidator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03059">CLI::detail::ExistingFileValidator::ExistingFileValidator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03095">CLI::detail::ExistingPathValidator::ExistingPathValidator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03110">CLI::detail::NonexistentPathValidator::NonexistentPathValidator()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03857">split_program_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a197be0b62b4d4deef0f5cac600a6b759_icgraph.svg" width="655" height="395"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac1a57be7d4de9c0552f91b8f16d47aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a57be7d4de9c0552f91b8f16d47aad">&#9670;&nbsp;</a></span>checked_multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, bool&gt;::type CLI::detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03381">3381</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03381"></a><span class="lineno"> 3381</span>&#160;                                                                                            {</div>
<div class="line"><a name="l03382"></a><span class="lineno"> 3382</span>&#160;            <span class="keywordflow">if</span> (a == 0 || b == 0 || a == 1 || b == 1) {</div>
<div class="line"><a name="l03383"></a><span class="lineno"> 3383</span>&#160;                a *= b;</div>
<div class="line"><a name="l03384"></a><span class="lineno"> 3384</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l03385"></a><span class="lineno"> 3385</span>&#160;            }</div>
<div class="line"><a name="l03386"></a><span class="lineno"> 3386</span>&#160;            <span class="keywordflow">if</span> (a == (std::numeric_limits&lt;T&gt;::min)() || b == (std::numeric_limits&lt;T&gt;::min)()) {</div>
<div class="line"><a name="l03387"></a><span class="lineno"> 3387</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l03388"></a><span class="lineno"> 3388</span>&#160;            }</div>
<div class="line"><a name="l03389"></a><span class="lineno"> 3389</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">overflowCheck</a>(a, b)) {</div>
<div class="line"><a name="l03390"></a><span class="lineno"> 3390</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l03391"></a><span class="lineno"> 3391</span>&#160;            }</div>
<div class="line"><a name="l03392"></a><span class="lineno"> 3392</span>&#160;            a *= b;</div>
<div class="line"><a name="l03393"></a><span class="lineno"> 3393</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l03394"></a><span class="lineno"> 3394</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_ad9da7d60b3b5738079257829c777c9c7"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">CLI::detail::overflowCheck</a></div><div class="ttdeci">std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type overflowCheck(const T &amp;a, const T &amp;b)</div><div class="ttdoc">Do a check for overflow on unsigned numbers.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03375">CLI11.hpp:3375</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03375">overflowCheck()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08236">CLI::App::_parse_arg()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l04866">CLI::Option::get_items_expected_max()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac1a57be7d4de9c0552f91b8f16d47aad_cgraph.svg" width="399" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac1a57be7d4de9c0552f91b8f16d47aad_icgraph.svg" width="590" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaf8289908c3b0f3fa2cb597f787a06aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8289908c3b0f3fa2cb597f787a06aa">&#9670;&nbsp;</a></span>checked_multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, bool&gt;::type CLI::detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't equal infinity. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03398">3398</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03398"></a><span class="lineno"> 3398</span>&#160;                                                                                                  {</div>
<div class="line"><a name="l03399"></a><span class="lineno"> 3399</span>&#160;            T c = a * b;</div>
<div class="line"><a name="l03400"></a><span class="lineno"> 3400</span>&#160;            <span class="keywordflow">if</span> (std::isinf(c) &amp;&amp; !std::isinf(a) &amp;&amp; !std::isinf(b)) {</div>
<div class="line"><a name="l03401"></a><span class="lineno"> 3401</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l03402"></a><span class="lineno"> 3402</span>&#160;            }</div>
<div class="line"><a name="l03403"></a><span class="lineno"> 3403</span>&#160;            a = c;</div>
<div class="line"><a name="l03404"></a><span class="lineno"> 3404</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l03405"></a><span class="lineno"> 3405</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae396058c9ea28259db0c05376bf9c1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae396058c9ea28259db0c05376bf9c1de">&#9670;&nbsp;</a></span>checked_to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01258">1258</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;                                         {</div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;            <span class="keywordflow">return</span> std::string{};</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bcb244a7701fc68da3a863b58daf615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcb244a7701fc68da3a863b58daf615">&#9670;&nbsp;</a></span>checked_to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(std::forward&lt;T&gt;(value))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01252">1252</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;                                                                                       {</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">to_string</a>(std::forward&lt;T&gt;(value));</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a9c070858740ce15aaecb1c5f04e21a09"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">CLI::detail::to_string</a></div><div class="ttdeci">std::string to_string(T &amp;&amp;value)</div><div class="ttdoc">Convert an object to a string (streaming must be supported for that type)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l01220">CLI11.hpp:1220</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01220">to_string()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a1bcb244a7701fc68da3a863b58daf615_cgraph.svg" width="359" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af3c3c6f67c8fef09def5f328856dd154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c3c6f67c8fef09def5f328856dd154">&#9670;&nbsp;</a></span>checkParentSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLI::detail::checkParentSegments </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_c_l_i_1_1_config_item.html">ConfigItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>currentSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>parentSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assuming non default segments do a check on the close and open of the segments in a configItem structure </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08866">8866</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08866"></a><span class="lineno"> 8866</span>&#160;                                                                                                                              {</div>
<div class="line"><a name="l08867"></a><span class="lineno"> 8867</span>&#160;            std::string estring;</div>
<div class="line"><a name="l08868"></a><span class="lineno"> 8868</span>&#160;            <span class="keyword">auto</span> parents = <a class="code" href="namespace_c_l_i_1_1detail.html#a36d5b7ba1cbf90d9882ab35c67156469">detail::generate_parents</a>(currentSection, estring, parentSeparator);</div>
<div class="line"><a name="l08869"></a><span class="lineno"> 8869</span>&#160;            <span class="keywordflow">if</span> (!output.empty() &amp;&amp; output.back().name == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><a name="l08870"></a><span class="lineno"> 8870</span>&#160;                std::size_t msize = (parents.size() &gt; 1U) ? parents.size() : 2;</div>
<div class="line"><a name="l08871"></a><span class="lineno"> 8871</span>&#160;                <span class="keywordflow">while</span> (output.back().parents.size() &gt;= msize) {</div>
<div class="line"><a name="l08872"></a><span class="lineno"> 8872</span>&#160;                    output.push_back(output.back());</div>
<div class="line"><a name="l08873"></a><span class="lineno"> 8873</span>&#160;                    output.back().parents.pop_back();</div>
<div class="line"><a name="l08874"></a><span class="lineno"> 8874</span>&#160;                }</div>
<div class="line"><a name="l08875"></a><span class="lineno"> 8875</span>&#160; </div>
<div class="line"><a name="l08876"></a><span class="lineno"> 8876</span>&#160;                <span class="keywordflow">if</span> (parents.size() &gt; 1) {</div>
<div class="line"><a name="l08877"></a><span class="lineno"> 8877</span>&#160;                    std::size_t common = 0;</div>
<div class="line"><a name="l08878"></a><span class="lineno"> 8878</span>&#160;                    std::size_t mpair = (std::min)(output.back().parents.size(), parents.size() - 1);</div>
<div class="line"><a name="l08879"></a><span class="lineno"> 8879</span>&#160;                    <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; mpair; ++ii) {</div>
<div class="line"><a name="l08880"></a><span class="lineno"> 8880</span>&#160;                        <span class="keywordflow">if</span> (output.back().parents[ii] != parents[ii]) {</div>
<div class="line"><a name="l08881"></a><span class="lineno"> 8881</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l08882"></a><span class="lineno"> 8882</span>&#160;                        }</div>
<div class="line"><a name="l08883"></a><span class="lineno"> 8883</span>&#160;                        ++common;</div>
<div class="line"><a name="l08884"></a><span class="lineno"> 8884</span>&#160;                    }</div>
<div class="line"><a name="l08885"></a><span class="lineno"> 8885</span>&#160;                    <span class="keywordflow">if</span> (common == mpair) {</div>
<div class="line"><a name="l08886"></a><span class="lineno"> 8886</span>&#160;                        output.pop_back();</div>
<div class="line"><a name="l08887"></a><span class="lineno"> 8887</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l08888"></a><span class="lineno"> 8888</span>&#160;                        <span class="keywordflow">while</span> (output.back().parents.size() &gt; common + 1) {</div>
<div class="line"><a name="l08889"></a><span class="lineno"> 8889</span>&#160;                            output.push_back(output.back());</div>
<div class="line"><a name="l08890"></a><span class="lineno"> 8890</span>&#160;                            output.back().parents.pop_back();</div>
<div class="line"><a name="l08891"></a><span class="lineno"> 8891</span>&#160;                        }</div>
<div class="line"><a name="l08892"></a><span class="lineno"> 8892</span>&#160;                    }</div>
<div class="line"><a name="l08893"></a><span class="lineno"> 8893</span>&#160;                    <span class="keywordflow">for</span> (std::size_t ii = common; ii &lt; parents.size() - 1; ++ii) {</div>
<div class="line"><a name="l08894"></a><span class="lineno"> 8894</span>&#160;                        output.emplace_back();</div>
<div class="line"><a name="l08895"></a><span class="lineno"> 8895</span>&#160;                        output.back().parents.assign(parents.begin(), parents.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(ii) + 1);</div>
<div class="line"><a name="l08896"></a><span class="lineno"> 8896</span>&#160;                        output.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><a name="l08897"></a><span class="lineno"> 8897</span>&#160;                    }</div>
<div class="line"><a name="l08898"></a><span class="lineno"> 8898</span>&#160;                }</div>
<div class="line"><a name="l08899"></a><span class="lineno"> 8899</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parents.size() &gt; 1) {</div>
<div class="line"><a name="l08900"></a><span class="lineno"> 8900</span>&#160;                <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; parents.size() - 1; ++ii) {</div>
<div class="line"><a name="l08901"></a><span class="lineno"> 8901</span>&#160;                    output.emplace_back();</div>
<div class="line"><a name="l08902"></a><span class="lineno"> 8902</span>&#160;                    output.back().parents.assign(parents.begin(), parents.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(ii) + 1);</div>
<div class="line"><a name="l08903"></a><span class="lineno"> 8903</span>&#160;                    output.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><a name="l08904"></a><span class="lineno"> 8904</span>&#160;                }</div>
<div class="line"><a name="l08905"></a><span class="lineno"> 8905</span>&#160;            }</div>
<div class="line"><a name="l08906"></a><span class="lineno"> 8906</span>&#160; </div>
<div class="line"><a name="l08907"></a><span class="lineno"> 8907</span>&#160;            <span class="comment">// insert a section end which is just an empty items_buffer</span></div>
<div class="line"><a name="l08908"></a><span class="lineno"> 8908</span>&#160;            output.emplace_back();</div>
<div class="line"><a name="l08909"></a><span class="lineno"> 8909</span>&#160;            output.back().parents = std::move(parents);</div>
<div class="line"><a name="l08910"></a><span class="lineno"> 8910</span>&#160;            output.back().name = <span class="stringliteral">&quot;++&quot;</span>;</div>
<div class="line"><a name="l08911"></a><span class="lineno"> 8911</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a36d5b7ba1cbf90d9882ab35c67156469"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a36d5b7ba1cbf90d9882ab35c67156469">CLI::detail::generate_parents</a></div><div class="ttdeci">std::vector&lt; std::string &gt; generate_parents(const std::string &amp;section, std::string &amp;name, char parentSeparator)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l08841">CLI11.hpp:8841</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l08841">generate_parents()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08914">CLI::ConfigBase::from_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af3c3c6f67c8fef09def5f328856dd154_cgraph.svg" width="586" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af3c3c6f67c8fef09def5f328856dd154_icgraph.svg" width="396" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2382165480a50710d41e421dd54079a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2382165480a50710d41e421dd54079a7">&#9670;&nbsp;</a></span>convert_arg_for_ini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::convert_arg_for_ini </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>stringQuote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>characterQuote</em> = <code>'\''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08766">8766</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08766"></a><span class="lineno"> 8766</span>&#160;                                                                                                                       {</div>
<div class="line"><a name="l08767"></a><span class="lineno"> 8767</span>&#160;            <span class="keywordflow">if</span> (arg.empty()) {</div>
<div class="line"><a name="l08768"></a><span class="lineno"> 8768</span>&#160;                <span class="keywordflow">return</span> std::string(2, stringQuote);</div>
<div class="line"><a name="l08769"></a><span class="lineno"> 8769</span>&#160;            }</div>
<div class="line"><a name="l08770"></a><span class="lineno"> 8770</span>&#160;            <span class="comment">// some specifically supported strings</span></div>
<div class="line"><a name="l08771"></a><span class="lineno"> 8771</span>&#160;            <span class="keywordflow">if</span> (arg == <span class="stringliteral">&quot;true&quot;</span> || arg == <span class="stringliteral">&quot;false&quot;</span> || arg == <span class="stringliteral">&quot;nan&quot;</span> || arg == <span class="stringliteral">&quot;inf&quot;</span>) {</div>
<div class="line"><a name="l08772"></a><span class="lineno"> 8772</span>&#160;                <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08773"></a><span class="lineno"> 8773</span>&#160;            }</div>
<div class="line"><a name="l08774"></a><span class="lineno"> 8774</span>&#160;            <span class="comment">// floating point conversion can convert some hex codes, but don&#39;t try that here</span></div>
<div class="line"><a name="l08775"></a><span class="lineno"> 8775</span>&#160;            <span class="keywordflow">if</span> (arg.compare(0, 2, <span class="stringliteral">&quot;0x&quot;</span>) != 0 &amp;&amp; arg.compare(0, 2, <span class="stringliteral">&quot;0X&quot;</span>) != 0) {</div>
<div class="line"><a name="l08776"></a><span class="lineno"> 8776</span>&#160;                <span class="keywordtype">double</span> val;</div>
<div class="line"><a name="l08777"></a><span class="lineno"> 8777</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">detail::lexical_cast</a>(arg, val)) {</div>
<div class="line"><a name="l08778"></a><span class="lineno"> 8778</span>&#160;                    <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08779"></a><span class="lineno"> 8779</span>&#160;                }</div>
<div class="line"><a name="l08780"></a><span class="lineno"> 8780</span>&#160;            }</div>
<div class="line"><a name="l08781"></a><span class="lineno"> 8781</span>&#160;            <span class="comment">// just quote a single non numeric character</span></div>
<div class="line"><a name="l08782"></a><span class="lineno"> 8782</span>&#160;            <span class="keywordflow">if</span> (arg.size() == 1) {</div>
<div class="line"><a name="l08783"></a><span class="lineno"> 8783</span>&#160;                <span class="keywordflow">return</span> std::string(1, characterQuote) + arg + characterQuote;</div>
<div class="line"><a name="l08784"></a><span class="lineno"> 8784</span>&#160;            }</div>
<div class="line"><a name="l08785"></a><span class="lineno"> 8785</span>&#160;            <span class="comment">// handle hex, binary or octal arguments</span></div>
<div class="line"><a name="l08786"></a><span class="lineno"> 8786</span>&#160;            <span class="keywordflow">if</span> (arg.front() == <span class="charliteral">&#39;0&#39;</span>) {</div>
<div class="line"><a name="l08787"></a><span class="lineno"> 8787</span>&#160;                <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;x&#39;</span>) {</div>
<div class="line"><a name="l08788"></a><span class="lineno"> 8788</span>&#160;                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><a name="l08789"></a><span class="lineno"> 8789</span>&#160;                            return (x &gt;= <span class="stringliteral">&#39;0&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;9&#39;</span>) || (x &gt;= <span class="stringliteral">&#39;A&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;F&#39;</span>) || (x &gt;= <span class="stringliteral">&#39;a&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;f&#39;</span>);</div>
<div class="line"><a name="l08790"></a><span class="lineno"> 8790</span>&#160;                        })) {</div>
<div class="line"><a name="l08791"></a><span class="lineno"> 8791</span>&#160;                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08792"></a><span class="lineno"> 8792</span>&#160;                    }</div>
<div class="line"><a name="l08793"></a><span class="lineno"> 8793</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;o&#39;</span>) {</div>
<div class="line"><a name="l08794"></a><span class="lineno"> 8794</span>&#160;                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><a name="l08795"></a><span class="lineno"> 8795</span>&#160;                            return (x &gt;= <span class="stringliteral">&#39;0&#39;</span> &amp;&amp; x &lt;= <span class="stringliteral">&#39;7&#39;</span>);</div>
<div class="line"><a name="l08796"></a><span class="lineno"> 8796</span>&#160;                        })) {</div>
<div class="line"><a name="l08797"></a><span class="lineno"> 8797</span>&#160;                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08798"></a><span class="lineno"> 8798</span>&#160;                    }</div>
<div class="line"><a name="l08799"></a><span class="lineno"> 8799</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg[1] == <span class="charliteral">&#39;b&#39;</span>) {</div>
<div class="line"><a name="l08800"></a><span class="lineno"> 8800</span>&#160;                    <span class="keywordflow">if</span> (std::all_of(arg.begin() + 2, arg.end(), [](<span class="keywordtype">char</span> x) {</div>
<div class="line"><a name="l08801"></a><span class="lineno"> 8801</span>&#160;                            return (x == <span class="stringliteral">&#39;0&#39;</span> || x == <span class="stringliteral">&#39;1&#39;</span>);</div>
<div class="line"><a name="l08802"></a><span class="lineno"> 8802</span>&#160;                        })) {</div>
<div class="line"><a name="l08803"></a><span class="lineno"> 8803</span>&#160;                        <span class="keywordflow">return</span> arg;</div>
<div class="line"><a name="l08804"></a><span class="lineno"> 8804</span>&#160;                    }</div>
<div class="line"><a name="l08805"></a><span class="lineno"> 8805</span>&#160;                }</div>
<div class="line"><a name="l08806"></a><span class="lineno"> 8806</span>&#160;            }</div>
<div class="line"><a name="l08807"></a><span class="lineno"> 8807</span>&#160;            <span class="keywordflow">if</span> (arg.find_first_of(stringQuote) == std::string::npos) {</div>
<div class="line"><a name="l08808"></a><span class="lineno"> 8808</span>&#160;                <span class="keywordflow">return</span> std::string(1, stringQuote) + arg + stringQuote;</div>
<div class="line"><a name="l08809"></a><span class="lineno"> 8809</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l08810"></a><span class="lineno"> 8810</span>&#160;                <span class="keywordflow">return</span> characterQuote + arg + characterQuote;</div>
<div class="line"><a name="l08811"></a><span class="lineno"> 8811</span>&#160;            }</div>
<div class="line"><a name="l08812"></a><span class="lineno"> 8812</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_af286727de86fce444325681379e2c511"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">CLI::detail::lexical_cast</a></div><div class="ttdeci">bool lexical_cast(const std::string &amp;input, T &amp;output)</div><div class="ttdoc">Integer conversion.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l01810">CLI11.hpp:1810</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01810">lexical_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08815">ini_join()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l09046">CLI::ConfigBase::to_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a2382165480a50710d41e421dd54079a7_cgraph.svg" width="568" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a2382165480a50710d41e421dd54079a7_icgraph.svg" width="539" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac24078bb1f5e51808a5001a47d2b40c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24078bb1f5e51808a5001a47d2b40c3">&#9670;&nbsp;</a></span>escape_detect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CLI::detail::escape_detect </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function detects an equal or colon followed by an escaped quote after an argument then modifies the string to replace the equality with a space. This is needed to allow the split up function to work properly and is intended to be used with the find_and_modify function the return value is the offset+1 which is required by the find_and_modify function. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00525">525</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                                                                         {</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            <span class="keyword">auto</span> next = str[offset + 1];</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="keywordflow">if</span> ((next == <span class="charliteral">&#39;\&quot;&#39;</span>) || (next == <span class="charliteral">&#39;\&#39;&#39;</span>) || (next == <span class="charliteral">&#39;`&#39;</span>)) {</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                <span class="keyword">auto</span> astart = str.find_last_of(<span class="stringliteral">&quot;-/ \&quot;\&#39;`&quot;</span>, offset - 1);</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                <span class="keywordflow">if</span> (astart != std::string::npos) {</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                    <span class="keywordflow">if</span> (str[astart] == ((str[offset] == <span class="charliteral">&#39;=&#39;</span>) ? <span class="charliteral">&#39;-&#39;</span> : <span class="charliteral">&#39;/&#39;</span>))</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                        str[offset] = <span class="charliteral">&#39; &#39;</span>; <span class="comment">// interpret this as a space so the split_up works properly</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                }</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;            }</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;            <span class="keywordflow">return</span> offset + 1;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06688">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac24078bb1f5e51808a5001a47d2b40c3_icgraph.svg" width="319" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a59fbb1952b19838d8377ab714dc33e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fbb1952b19838d8377ab714dc33e4c">&#9670;&nbsp;</a></span>find_and_modify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::find_and_modify </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>modify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a trigger string and call a modify callable function that takes the current string and starting position of the trigger and returns the position in the string to search for the next trigger string </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00460">460</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            std::size_t start_pos = 0;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;            <span class="keywordflow">while</span> ((start_pos = str.find(trigger, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                start_pos = modify(str, start_pos);</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            }</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06688">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a59fbb1952b19838d8377ab714dc33e4c_icgraph.svg" width="328" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab39b1977d7375250cc57d90723cf1554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39b1977d7375250cc57d90723cf1554">&#9670;&nbsp;</a></span>find_and_replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::find_and_replace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and replace a substring with another substring. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00400">400</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                                                                                       {</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            std::size_t start_pos = 0;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160; </div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;            <span class="keywordflow">while</span> ((start_pos = str.find(from, start_pos)) != std::string::npos) {</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                str.replace(start_pos, from.length(), to);</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                start_pos += to.length();</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            }</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160; </div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09330">CLI::Formatter::make_expanded()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03857">split_program_name()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00470">split_up()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ab39b1977d7375250cc57d90723cf1554_icgraph.svg" width="579" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a356b9c9cc904af2b0a918fd55e86cd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356b9c9cc904af2b0a918fd55e86cd9c">&#9670;&nbsp;</a></span>find_member()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t CLI::detail::find_member </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_underscore</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a string is a member of a list of strings and optionally ignore case or ignore underscores. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00430">430</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                                                                                                                                {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            <span class="keyword">auto</span> it = std::end(names);</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i.html#a0c52326d2681814c22aa1a93ce43375e">ignore_case</a>) {</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">ignore_underscore</a>) {</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                    name = <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(name));</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                    it = std::find_if(std::begin(names), std::end(names), [&amp;name](std::string local_name) {</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                        <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(local_name)) == name;</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                    });</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                    name = <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(name);</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                    it = std::find_if(std::begin(names), std::end(names), [&amp;name](std::string local_name) {</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                        <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(local_name) == name;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                    });</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                }</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160; </div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">ignore_underscore</a>) {</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                name = <a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(name);</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                it = std::find_if(std::begin(names), std::end(names), [&amp;name](std::string local_name) {</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">detail::remove_underscore</a>(local_name) == name;</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                });</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                it = std::find(std::begin(names), std::end(names), name);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;            }</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160; </div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            <span class="keywordflow">return</span> (it != std::end(names)) ? (it - std::begin(names)) : (-1);</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a5359a7a0e33366a12e15523b100f591a"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">CLI::detail::remove_underscore</a></div><div class="ttdeci">std::string remove_underscore(std::string str)</div><div class="ttdoc">remove underscores from a string</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00394">CLI11.hpp:394</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_ae83709ec148057ec53df4383645727e9"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">CLI::detail::to_lower</a></div><div class="ttdeci">std::string to_lower(std::string str)</div><div class="ttdoc">Return a lower case version of a string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00386">CLI11.hpp:386</a></div></div>
<div class="ttc" id="anamespace_c_l_i_html_a0c52326d2681814c22aa1a93ce43375e"><div class="ttname"><a href="namespace_c_l_i.html#a0c52326d2681814c22aa1a93ce43375e">CLI::ignore_case</a></div><div class="ttdeci">std::string ignore_case(std::string item)</div><div class="ttdoc">Helper function to allow ignore_case to be passed to IsMember or Transform.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03638">CLI11.hpp:3638</a></div></div>
<div class="ttc" id="anamespace_c_l_i_html_a111b6f05d21b9b84e7ba933ade79884c"><div class="ttname"><a href="namespace_c_l_i.html#a111b6f05d21b9b84e7ba933ade79884c">CLI::ignore_underscore</a></div><div class="ttdeci">std::string ignore_underscore(std::string item)</div><div class="ttdoc">Helper function to allow ignore_underscore to be passed to IsMember or Transform.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03643">CLI11.hpp:3643</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03638">CLI::ignore_case()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03643">CLI::ignore_underscore()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00394">remove_underscore()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00386">to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05068">CLI::Option::check_fname()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05063">CLI::Option::check_lname()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05058">CLI::Option::check_sname()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l05077">CLI::Option::get_flag_value()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a356b9c9cc904af2b0a918fd55e86cd9c_cgraph.svg" width="611" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a356b9c9cc904af2b0a918fd55e86cd9c_icgraph.svg" width="878" height="248"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6f983b056b683129ec20e53d8c6141ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f983b056b683129ec20e53d8c6141ab">&#9670;&nbsp;</a></span>fix_newlines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::fix_newlines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>leader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a leader to the beginning of all new lines (nothing is added at the start of the first line). <code>"; "</code> would be for ini files</p>
<p>Can't use Regex, or this would be a subs. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00285">285</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                                                                                {</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            std::string::size_type n = 0;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            <span class="keywordflow">while</span> (n != std::string::npos &amp;&amp; n &lt; input.size()) {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                n = input.find(<span class="charliteral">&#39;\n&#39;</span>, n);</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                <span class="keywordflow">if</span> (n != std::string::npos) {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                    input = input.substr(0, n + 1) + leader + input.substr(n + 1);</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                    n += leader.size();</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                }</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            }</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keywordflow">return</span> input;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l00321">format_aliases()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l09046">CLI::ConfigBase::to_config()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a6f983b056b683129ec20e53d8c6141ab_icgraph.svg" width="588" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af375283ee4242348cd6d3df419d7bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af375283ee4242348cd6d3df419d7bc62">&#9670;&nbsp;</a></span>format_aliases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CLI::detail::format_aliases </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>wid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print subcommand aliases. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00321">321</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                                                                                                               {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keywordflow">if</span> (!aliases.empty()) {</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                out &lt;&lt; std::setw(static_cast&lt;int&gt;(wid)) &lt;&lt; <span class="stringliteral">&quot;     aliases: &quot;</span>;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                <span class="keywordtype">bool</span> front = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; alias : aliases) {</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                    <span class="keywordflow">if</span> (!front) {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                        out &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                        front = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                    }</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                    out &lt;&lt; <a class="code" href="namespace_c_l_i_1_1detail.html#a6f983b056b683129ec20e53d8c6141ab">detail::fix_newlines</a>(<span class="stringliteral">&quot;              &quot;</span>, alias);</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                }</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            }</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a6f983b056b683129ec20e53d8c6141ab"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a6f983b056b683129ec20e53d8c6141ab">CLI::detail::fix_newlines</a></div><div class="ttdeci">std::string fix_newlines(const std::string &amp;leader, std::string input)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00285">CLI11.hpp:285</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00285">fix_newlines()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09330">CLI::Formatter::make_expanded()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af375283ee4242348cd6d3df419d7bc62_cgraph.svg" width="375" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af375283ee4242348cd6d3df419d7bc62_icgraph.svg" width="356" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a569874f0c04636b7f0e63f40caf6e170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569874f0c04636b7f0e63f40caf6e170">&#9670;&nbsp;</a></span>format_help()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CLI::detail::format_help </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>wid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a two part "help" string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00303">303</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                                                                                                                     {</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            name = <span class="stringliteral">&quot;  &quot;</span> + name;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            out &lt;&lt; std::setw(static_cast&lt;int&gt;(wid)) &lt;&lt; std::left &lt;&lt; name;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="keywordflow">if</span> (!description.empty()) {</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                <span class="keywordflow">if</span> (name.length() &gt;= wid)</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                    out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; std::setw(<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(wid)) &lt;&lt; <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> c : description) {</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                    out.put(c);</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                    <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;\n&#39;</span>) {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                        out &lt;&lt; std::setw(static_cast&lt;int&gt;(wid)) &lt;&lt; <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                    }</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                }</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            }</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l04055">CLI::Formatter::make_option()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l09324">CLI::Formatter::make_subcommand()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a569874f0c04636b7f0e63f40caf6e170_icgraph.svg" width="392" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a65d0ac7d1e313c85e8027b8e7a82d29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d0ac7d1e313c85e8027b8e7a82d29a">&#9670;&nbsp;</a></span>from_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::from_stream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>istring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated operation to get a value from a stream. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01136">1136</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;                                                           {</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;            std::istringstream is;</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;            is.str(istring);</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;            is &gt;&gt; obj;</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;            <span class="keywordflow">return</span> !is.fail() &amp;&amp; !is.rdbuf()-&gt;in_avail();</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a320e031a5eb12297a140d2d6fc73362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320e031a5eb12297a140d2d6fc73362a">&#9670;&nbsp;</a></span>generate_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::generate_map </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>key_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a map. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03291">3291</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;                                                                    {</div>
<div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;            <span class="keyword">using</span> iteration_type_t = <span class="keyword">typename</span> detail::pair_adaptor&lt;element_t&gt;::value_type; <span class="comment">// the type of the object pair</span></div>
<div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160;            std::string out(1, <span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;            out.append(<a class="code" href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">detail::join</a>(</div>
<div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(map),</div>
<div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;                [key_only](<span class="keyword">const</span> iteration_type_t&amp; v) {</div>
<div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;                    std::string res{<a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">detail::to_string</a>(detail::pair_adaptor&lt;element_t&gt;::first(v))};</div>
<div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160; </div>
<div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;                    <span class="keywordflow">if</span> (!key_only) {</div>
<div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160;                        res.append(<span class="stringliteral">&quot;-&gt;&quot;</span>);</div>
<div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160;                        res += <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">detail::to_string</a>(detail::pair_adaptor&lt;element_t&gt;::second(v));</div>
<div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;                    }</div>
<div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;                    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160;                },</div>
<div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;                <span class="stringliteral">&quot;,&quot;</span>));</div>
<div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160;            out.push_back(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a8597debec6c8bc164109538253ffc623"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">CLI::detail::join</a></div><div class="ttdeci">std::string join(const T &amp;v, Callable func, std::string delim=&quot;,&quot;)</div><div class="ttdoc">Simple function to join a string from processed elements.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00188">CLI11.hpp:188</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_adcd67b783a1c4441c89f071774ac398b"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">CLI::detail::smart_deref</a></div><div class="ttdeci">std::remove_reference&lt; T &gt;::type &amp; smart_deref(T &amp;value)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03270">CLI11.hpp:3270</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00172">join()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03264">smart_deref()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l01203">to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03573">CLI::CheckedTransformer::CheckedTransformer()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03507">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a320e031a5eb12297a140d2d6fc73362a_cgraph.svg" width="400" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a320e031a5eb12297a140d2d6fc73362a_icgraph.svg" width="464" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a36d5b7ba1cbf90d9882ab35c67156469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d5b7ba1cbf90d9882ab35c67156469">&#9670;&nbsp;</a></span>generate_parents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::generate_parents </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>parentSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08841">8841</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08841"></a><span class="lineno"> 8841</span>&#160;                                                                                                                      {</div>
<div class="line"><a name="l08842"></a><span class="lineno"> 8842</span>&#160;            std::vector&lt;std::string&gt; parents;</div>
<div class="line"><a name="l08843"></a><span class="lineno"> 8843</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(section) != <span class="stringliteral">&quot;default&quot;</span>) {</div>
<div class="line"><a name="l08844"></a><span class="lineno"> 8844</span>&#160;                <span class="keywordflow">if</span> (section.find(parentSeparator) != std::string::npos) {</div>
<div class="line"><a name="l08845"></a><span class="lineno"> 8845</span>&#160;                    parents = <a class="code" href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">detail::split</a>(section, parentSeparator);</div>
<div class="line"><a name="l08846"></a><span class="lineno"> 8846</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l08847"></a><span class="lineno"> 8847</span>&#160;                    parents = {section};</div>
<div class="line"><a name="l08848"></a><span class="lineno"> 8848</span>&#160;                }</div>
<div class="line"><a name="l08849"></a><span class="lineno"> 8849</span>&#160;            }</div>
<div class="line"><a name="l08850"></a><span class="lineno"> 8850</span>&#160;            <span class="keywordflow">if</span> (name.find(parentSeparator) != std::string::npos) {</div>
<div class="line"><a name="l08851"></a><span class="lineno"> 8851</span>&#160;                std::vector&lt;std::string&gt; plist = <a class="code" href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">detail::split</a>(name, parentSeparator);</div>
<div class="line"><a name="l08852"></a><span class="lineno"> 8852</span>&#160;                name = plist.back();</div>
<div class="line"><a name="l08853"></a><span class="lineno"> 8853</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">detail::remove_quotes</a>(name);</div>
<div class="line"><a name="l08854"></a><span class="lineno"> 8854</span>&#160;                plist.pop_back();</div>
<div class="line"><a name="l08855"></a><span class="lineno"> 8855</span>&#160;                parents.insert(parents.end(), plist.begin(), plist.end());</div>
<div class="line"><a name="l08856"></a><span class="lineno"> 8856</span>&#160;            }</div>
<div class="line"><a name="l08857"></a><span class="lineno"> 8857</span>&#160; </div>
<div class="line"><a name="l08858"></a><span class="lineno"> 8858</span>&#160;            <span class="comment">// clean up quotes on the parents</span></div>
<div class="line"><a name="l08859"></a><span class="lineno"> 8859</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; parent : parents) {</div>
<div class="line"><a name="l08860"></a><span class="lineno"> 8860</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">detail::remove_quotes</a>(parent);</div>
<div class="line"><a name="l08861"></a><span class="lineno"> 8861</span>&#160;            }</div>
<div class="line"><a name="l08862"></a><span class="lineno"> 8862</span>&#160;            <span class="keywordflow">return</span> parents;</div>
<div class="line"><a name="l08863"></a><span class="lineno"> 8863</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a242fa1bec3353c591a730efc6307f3ea"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">CLI::detail::remove_quotes</a></div><div class="ttdeci">std::string &amp; remove_quotes(std::string &amp;str)</div><div class="ttdoc">remove quotes at the front and back of a string either '&quot;' or '\''</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00271">CLI11.hpp:271</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a9e78d046d8a9c2d6f246bd1e36e57ec6"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">CLI::detail::split</a></div><div class="ttdeci">std::vector&lt; std::string &gt; split(const std::string &amp;s, char delim)</div><div class="ttdoc">Split a string by a delim.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00154">CLI11.hpp:154</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00271">remove_quotes()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00154">split()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00386">to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08866">checkParentSegments()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l08914">CLI::ConfigBase::from_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a36d5b7ba1cbf90d9882ab35c67156469_cgraph.svg" width="363" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a36d5b7ba1cbf90d9882ab35c67156469_icgraph.svg" width="598" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a75f66945cfe53b556e4c311f9a88a155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f66945cfe53b556e4c311f9a88a155">&#9670;&nbsp;</a></span>generate_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::generate_set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a set. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03275">3275</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;                                             {</div>
<div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;            <span class="keyword">using</span> iteration_type_t = <span class="keyword">typename</span> detail::pair_adaptor&lt;element_t&gt;::value_type; <span class="comment">// the type of the object pair</span></div>
<div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;            std::string out(1, <span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160;            out.append(<a class="code" href="namespace_c_l_i_1_1detail.html#a8597debec6c8bc164109538253ffc623">detail::join</a>(</div>
<div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(set),</div>
<div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;                [](<span class="keyword">const</span> iteration_type_t&amp; v) {</div>
<div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160;                    <span class="keywordflow">return</span> detail::pair_adaptor&lt;element_t&gt;::first(v);</div>
<div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160;                },</div>
<div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160;                <span class="stringliteral">&quot;,&quot;</span>));</div>
<div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;            out.push_back(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;            <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01023">CLI::detail::pair_adaptor&lt; T, _ &gt;::first()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00172">join()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03264">smart_deref()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03428">CLI::IsMember::IsMember()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a75f66945cfe53b556e4c311f9a88a155_cgraph.svg" width="416" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a75f66945cfe53b556e4c311f9a88a155_icgraph.svg" width="427" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a49ea386ace9f320e1ba59d7eba49b7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ea386ace9f320e1ba59d7eba49b7cf">&#9670;&nbsp;</a></span>get_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; CLI::detail::get_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract default flag values either {def} or starting with a ! </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02532">2532</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;                                                                                                      {</div>
<div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;            std::vector&lt;std::string&gt; flags = <a class="code" href="namespace_c_l_i_1_1detail.html#abf817a10b92907070c02b752c37aa09d">split_names</a>(str);</div>
<div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;            flags.erase(std::remove_if(</div>
<div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;                            flags.begin(),</div>
<div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;                            flags.end(),</div>
<div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;                            [](<span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;                                return ((name.empty()) ||</div>
<div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;                                        (!(((name.find_first_of(<span class="stringliteral">&#39;{&#39;</span>) != std::string::npos) &amp;&amp; (name.back() == <span class="stringliteral">&#39;}&#39;</span>)) || (name[0] == <span class="stringliteral">&#39;!&#39;</span>))));</div>
<div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;                            }),</div>
<div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;                        flags.end());</div>
<div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;            std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; output;</div>
<div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;            output.reserve(flags.size());</div>
<div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; flag : flags) {</div>
<div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;                <span class="keyword">auto</span> def_start = flag.find_first_of(<span class="charliteral">&#39;{&#39;</span>);</div>
<div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;                std::string defval = <span class="stringliteral">&quot;false&quot;</span>;</div>
<div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;                <span class="keywordflow">if</span> ((def_start != std::string::npos) &amp;&amp; (flag.back() == <span class="charliteral">&#39;}&#39;</span>)) {</div>
<div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;                    defval = flag.substr(def_start + 1);</div>
<div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;                    defval.pop_back();</div>
<div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;                    flag.erase(def_start, std::string::npos);</div>
<div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;                }</div>
<div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;                flag.erase(0, flag.find_first_not_of(<span class="stringliteral">&quot;-!&quot;</span>));</div>
<div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;                output.emplace_back(flag, defval);</div>
<div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;            }</div>
<div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;            <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_abf817a10b92907070c02b752c37aa09d"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#abf817a10b92907070c02b752c37aa09d">CLI::detail::split_names</a></div><div class="ttdeci">std::vector&lt; std::string &gt; split_names(std::string current)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l02520">CLI11.hpp:2520</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l02520">split_names()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06224">CLI::App::_add_flag_internal()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a49ea386ace9f320e1ba59d7eba49b7cf_cgraph.svg" width="904" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a49ea386ace9f320e1ba59d7eba49b7cf_icgraph.svg" width="375" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a23ae97bbbd9e400bd94b316dd865cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ae97bbbd9e400bd94b316dd865cb66">&#9670;&nbsp;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;std::string&gt;, std::vector&lt;std::string&gt;, std::string&gt; CLI::detail::get_names </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of short names, one of long names, and a single name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02560">2560</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;                                                     {</div>
<div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;            std::vector&lt;std::string&gt; short_names;</div>
<div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;            std::vector&lt;std::string&gt; long_names;</div>
<div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;            std::string pos_name;</div>
<div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160; </div>
<div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;            <span class="keywordflow">for</span> (std::string name : input) {</div>
<div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;                <span class="keywordflow">if</span> (name.length() == 0) {</div>
<div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;                }</div>
<div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;                <span class="keywordflow">if</span> (name.length() &gt; 1 &amp;&amp; name[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; name[1] != <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;                    <span class="keywordflow">if</span> (name.length() == 2 &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(name[1]))</div>
<div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;                        short_names.emplace_back(1, name[1]);</div>
<div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;                        <span class="keywordflow">throw</span> BadNameString::OneCharName(name);</div>
<div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name.length() &gt; 2 &amp;&amp; name.substr(0, 2) == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;                    name = name.substr(2);</div>
<div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">valid_name_string</a>(name))</div>
<div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;                        long_names.push_back(name);</div>
<div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;                        <span class="keywordflow">throw</span> BadNameString::BadLongName(name);</div>
<div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;-&quot;</span> || name == <span class="stringliteral">&quot;--&quot;</span>) {</div>
<div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;                    <span class="keywordflow">throw</span> BadNameString::DashesOnly(name);</div>
<div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;                    <span class="keywordflow">if</span> (pos_name.length() &gt; 0)</div>
<div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;                        <span class="keywordflow">throw</span> BadNameString::MultiPositionalNames(name);</div>
<div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;                    pos_name = name;</div>
<div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;                }</div>
<div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;            }</div>
<div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160; </div>
<div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;            <span class="keywordflow">return</span> std::tuple&lt;std::vector&lt;std::string&gt;, std::vector&lt;std::string&gt;, std::string&gt;(short_names, long_names, pos_name);</div>
<div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a3a05d1129df69e88135e178137b1fd89"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">CLI::detail::valid_first_char</a></div><div class="ttdeci">bool valid_first_char(T c)</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00341">CLI11.hpp:341</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a4274628d24f9e3fbc719284f1db263b8"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">CLI::detail::valid_name_string</a></div><div class="ttdeci">bool valid_name_string(const std::string &amp;str)</div><div class="ttdoc">Verify an option/subcommand name.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00355">CLI11.hpp:355</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00672">CLI::BadNameString::BadLongName()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00675">CLI::BadNameString::DashesOnly()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00678">CLI::BadNameString::MultiPositionalNames()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00669">CLI::BadNameString::OneCharName()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00341">valid_first_char()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00355">valid_name_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l04421">CLI::Option::Option()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a23ae97bbbd9e400bd94b316dd865cb66_cgraph.svg" width="599" height="372"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a23ae97bbbd9e400bd94b316dd865cb66_icgraph.svg" width="370" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae89da9fa11d234a8bf504d6ec85133cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89da9fa11d234a8bf504d6ec85133cc">&#9670;&nbsp;</a></span>has_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::has_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if the flag definitions has possible false flags </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00412">412</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                                                                    {</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;            <span class="keywordflow">return</span> (flags.find_first_of(<span class="stringliteral">&quot;{!&quot;</span>) != std::string::npos);</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06224">CLI::App::_add_flag_internal()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ae89da9fa11d234a8bf504d6ec85133cc_icgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0b12b08c7bc02a39431b3da4f123e93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b12b08c7bc02a39431b3da4f123e93d">&#9670;&nbsp;</a></span>ini_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::ini_join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sepChar</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>arrayStart</em> = <code>'['</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>arrayEnd</em> = <code>']'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>stringQuote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>characterQuote</em> = <code>'\''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comma separated join, adds quotes if needed. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l08815">8815</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l08820"></a><span class="lineno"> 8820</span>&#160;                                                                {</div>
<div class="line"><a name="l08821"></a><span class="lineno"> 8821</span>&#160;            std::string joined;</div>
<div class="line"><a name="l08822"></a><span class="lineno"> 8822</span>&#160;            <span class="keywordflow">if</span> (args.size() &gt; 1 &amp;&amp; arrayStart != <span class="charliteral">&#39;\0&#39;</span>) {</div>
<div class="line"><a name="l08823"></a><span class="lineno"> 8823</span>&#160;                joined.push_back(arrayStart);</div>
<div class="line"><a name="l08824"></a><span class="lineno"> 8824</span>&#160;            }</div>
<div class="line"><a name="l08825"></a><span class="lineno"> 8825</span>&#160;            std::size_t start = 0;</div>
<div class="line"><a name="l08826"></a><span class="lineno"> 8826</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : args) {</div>
<div class="line"><a name="l08827"></a><span class="lineno"> 8827</span>&#160;                <span class="keywordflow">if</span> (start++ &gt; 0) {</div>
<div class="line"><a name="l08828"></a><span class="lineno"> 8828</span>&#160;                    joined.push_back(sepChar);</div>
<div class="line"><a name="l08829"></a><span class="lineno"> 8829</span>&#160;                    <span class="keywordflow">if</span> (isspace(sepChar) == 0) {</div>
<div class="line"><a name="l08830"></a><span class="lineno"> 8830</span>&#160;                        joined.push_back(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"><a name="l08831"></a><span class="lineno"> 8831</span>&#160;                    }</div>
<div class="line"><a name="l08832"></a><span class="lineno"> 8832</span>&#160;                }</div>
<div class="line"><a name="l08833"></a><span class="lineno"> 8833</span>&#160;                joined.append(<a class="code" href="namespace_c_l_i_1_1detail.html#a2382165480a50710d41e421dd54079a7">convert_arg_for_ini</a>(arg, stringQuote, characterQuote));</div>
<div class="line"><a name="l08834"></a><span class="lineno"> 8834</span>&#160;            }</div>
<div class="line"><a name="l08835"></a><span class="lineno"> 8835</span>&#160;            <span class="keywordflow">if</span> (args.size() &gt; 1 &amp;&amp; arrayEnd != <span class="charliteral">&#39;\0&#39;</span>) {</div>
<div class="line"><a name="l08836"></a><span class="lineno"> 8836</span>&#160;                joined.push_back(arrayEnd);</div>
<div class="line"><a name="l08837"></a><span class="lineno"> 8837</span>&#160;            }</div>
<div class="line"><a name="l08838"></a><span class="lineno"> 8838</span>&#160;            <span class="keywordflow">return</span> joined;</div>
<div class="line"><a name="l08839"></a><span class="lineno"> 8839</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a2382165480a50710d41e421dd54079a7"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a2382165480a50710d41e421dd54079a7">CLI::detail::convert_arg_for_ini</a></div><div class="ttdeci">std::string convert_arg_for_ini(const std::string &amp;arg, char stringQuote='&quot;', char characterQuote = '\'') </div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l08766">CLI11.hpp:8766</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l08766">convert_arg_for_ini()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l09046">CLI::ConfigBase::to_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0b12b08c7bc02a39431b3da4f123e93d_cgraph.svg" width="759" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0b12b08c7bc02a39431b3da4f123e93d_icgraph.svg" width="347" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af6685ecdb07b40a316035bb4af9b02e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6685ecdb07b40a316035bb4af9b02e6">&#9670;&nbsp;</a></span>integral_conversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::integral_conversion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to an unsigned integral. </p>
<p>Convert to a signed integral. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01740">1740</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;                                                                             {</div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;            <span class="keywordflow">if</span> (input.empty()) {</div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;            }</div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;            <span class="keywordtype">char</span>* val = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;            std::uint64_t output_ll = std::strtoull(input.c_str(), &amp;val, 0);</div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;            output = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(output_ll);</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;            <span class="keywordflow">return</span> val == (input.c_str() + input.size()) &amp;&amp; <span class="keyword">static_cast&lt;</span>std::uint64_t<span class="keyword">&gt;</span>(output) == output_ll;</div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l01810">lexical_cast()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af6685ecdb07b40a316035bb4af9b02e6_icgraph.svg" width="1024" height="652"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a53b46b96102830769cc02952392e782f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b46b96102830769cc02952392e782f">&#9670;&nbsp;</a></span>is_separator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::is_separator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a string is a container segment separator (empty or "%%") </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00373">373</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                                                       {</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string sep(<span class="stringliteral">&quot;%%&quot;</span>);</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            <span class="keywordflow">return</span> (str.empty() || str == sep);</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05344">CLI::Option::_validate_results()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a53b46b96102830769cc02952392e782f_icgraph.svg" width="395" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac89ce22647a9f697b800d9c47b9d956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89ce22647a9f697b800d9c47b9d956f">&#9670;&nbsp;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::isalpha </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that str consists of letters only. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00379">379</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                                                  {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            <span class="keywordflow">return</span> std::all_of(str.begin(), str.end(), [](<span class="keywordtype">char</span> c) {</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                return std::isalpha(c, std::locale());</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            });</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03751">CLI::AsNumberWithUnit::validate_mapping()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac89ce22647a9f697b800d9c47b9d956f_icgraph.svg" width="376" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8597debec6c8bc164109538253ffc623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8597debec6c8bc164109538253ffc623">&#9670;&nbsp;</a></span>join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callable , typename  = typename std::enable_if&lt;!std::is_constructible&lt;std::string, Callable&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to join a string from processed elements. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00188">188</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                                                                         {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            std::ostringstream s;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="keyword">auto</span> beg = std::begin(v);</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="keyword">auto</span> end = std::end(v);</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keyword">auto</span> loc = s.tellp();</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="keywordflow">while</span> (beg != end) {</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                <span class="keyword">auto</span> nloc = s.tellp();</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                <span class="keywordflow">if</span> (nloc &gt; loc) {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                    s &lt;&lt; delim;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                    loc = nloc;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                }</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                s &lt;&lt; func(*beg++);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="keywordflow">return</span> s.str();</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab351f13ec104e2cba19ec6baf4a552f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab351f13ec104e2cba19ec6baf4a552f6">&#9670;&nbsp;</a></span>join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to join a string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00172">172</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                                                          {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            std::ostringstream s;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keyword">auto</span> beg = std::begin(v);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="keyword">auto</span> end = std::end(v);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="keywordflow">if</span> (beg != end)</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                s &lt;&lt; *beg++;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="keywordflow">while</span> (beg != end) {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                s &lt;&lt; delim &lt;&lt; *beg++;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            }</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keywordflow">return</span> s.str();</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l07674">CLI::App::_process_requirements()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05384">CLI::Option::_reduce_results()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03573">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02608">CLI::ConfigItem::fullname()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03291">generate_map()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03275">generate_set()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04918">CLI::Option::get_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09206">CLI::Formatter::make_usage()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l08700">CLI::FailureMessage::simple()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ab351f13ec104e2cba19ec6baf4a552f6_icgraph.svg" width="842" height="754"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab6647281bf64bba7b07737297ae1895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6647281bf64bba7b07737297ae1895d">&#9670;&nbsp;</a></span>lexical_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AssignTo , typename ConvertTo , enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::lexical_assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignTo &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a value through lexical cast operations. </p>
<p>Assign a value from a lexical cast through constructing a value and move assigning it.</p>
<p>Assign a value converted from a string in lexical cast to the output value directly.</p>
<p>Assign a value through lexical cast operations Strings can be empty so we need to do a little different</p>
<p>Assign a value through lexical cast operations for int compatible values mainly for atomic operations on some compilers </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02024">2024</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;                                                                      {</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#af286727de86fce444325681379e2c511">lexical_cast</a>(input, output);</div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01810">lexical_cast()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ab6647281bf64bba7b07737297ae1895d_cgraph.svg" width="563" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af286727de86fce444325681379e2c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af286727de86fce444325681379e2c511">&#9670;&nbsp;</a></span>lexical_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::lexical_cast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer conversion. </p>
<p>Non-string parsable by a stream.</p>
<p>Non-string convertible from an int.</p>
<p>Assignable from double.</p>
<p>Assignable from int.</p>
<p>Assignable from double or int.</p>
<p>wrapper types</p>
<p>Enumerations.</p>
<p>String and similar constructible and copy assignment.</p>
<p>String and similar direct assignment.</p>
<p>complex</p>
<p>Floats.</p>
<p>Boolean values.</p>
<p>char values </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01810">1810</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;                                                             {</div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">integral_conversion</a>(input, output);</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_af6685ecdb07b40a316035bb4af9b02e6"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">CLI::detail::integral_conversion</a></div><div class="ttdeci">bool integral_conversion(const std::string &amp;input, T &amp;output) noexcept</div><div class="ttdoc">Convert to an unsigned integral.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l01740">CLI11.hpp:1740</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01740">integral_conversion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06291">CLI::App::add_flag()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06320">CLI::App::add_flag_callback()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03235">CLI::Bound::Bound()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03573">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08766">convert_arg_for_ini()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03125">CLI::detail::IPV4Validator::IPV4Validator()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03428">CLI::IsMember::IsMember()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02024">lexical_assign()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03507">CLI::Transformer::Transformer()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03170">CLI::TypeValidator&lt; DesiredType &gt;::TypeValidator()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af286727de86fce444325681379e2c511_cgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af286727de86fce444325681379e2c511_icgraph.svg" width="831" height="652"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acae078b951ab0e11b84dffe200d0049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae078b951ab0e11b84dffe200d0049c">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from left of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00219">219</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                                                {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.begin(), str.end(), [](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                return !std::isspace&lt;char&gt;(ch, std::locale());</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            });</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            str.erase(str.begin(), it);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l00255">trim()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_acae078b951ab0e11b84dffe200d0049c_icgraph.svg" width="742" height="236"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2cb44de7c57bbb1384f737dc2f04265b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb44de7c57bbb1384f737dc2f04265b">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from left of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00228">228</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                                                                         {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.begin(), str.end(), [&amp;filter](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                return filter.find(ch) == std::string::npos;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            });</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            str.erase(str.begin(), it);</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03857">split_program_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a2cb44de7c57bbb1384f737dc2f04265b_icgraph.svg" width="480" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac96583f0b43752f7fa77a6c24dae4802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96583f0b43752f7fa77a6c24dae4802">&#9670;&nbsp;</a></span>overflowCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_signed&lt;T&gt;::value, T&gt;::type CLI::detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on signed numbers. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03366">3366</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03366"></a><span class="lineno"> 3366</span>&#160;                                                                                                        {</div>
<div class="line"><a name="l03367"></a><span class="lineno"> 3367</span>&#160;            <span class="keywordflow">if</span> ((a &gt; 0) == (b &gt; 0)) {</div>
<div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;                <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::max)() / (std::abs)(a) &lt; (std::abs)(b));</div>
<div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;                <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::min)() / (std::abs)(a) &gt; -(std::abs)(b));</div>
<div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160;            }</div>
<div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9da7d60b3b5738079257829c777c9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9da7d60b3b5738079257829c777c9c7">&#9670;&nbsp;</a></span>overflowCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_signed&lt;T&gt;::value, T&gt;::type CLI::detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on unsigned numbers. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03375">3375</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160;                                                                                                         {</div>
<div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160;            <span class="keywordflow">return</span> ((std::numeric_limits&lt;T&gt;::max)() / a &lt; b);</div>
<div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03381">checked_multiply()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ad9da7d60b3b5738079257829c777c9c7_icgraph.svg" width="830" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a73b9afbe8a438ab30291d35f1f24c87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b9afbe8a438ab30291d35f1f24c87c">&#9670;&nbsp;</a></span>remove_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLI::detail::remove_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00416">416</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                                                                 {</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;            <span class="keyword">auto</span> loc = flags.find_first_of(<span class="charliteral">&#39;{&#39;</span>, 2);</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;            <span class="keywordflow">while</span> (loc != std::string::npos) {</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                <span class="keyword">auto</span> finish = flags.find_first_of(<span class="stringliteral">&quot;},&quot;</span>, loc + 1);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                <span class="keywordflow">if</span> ((finish != std::string::npos) &amp;&amp; (flags[finish] == <span class="charliteral">&#39;}&#39;</span>)) {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                    flags.erase(flags.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(loc), flags.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(finish) + 1);</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                }</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                loc = flags.find_first_of(<span class="charliteral">&#39;{&#39;</span>, loc + 1);</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            }</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            flags.erase(std::remove(flags.begin(), flags.end(), <span class="charliteral">&#39;!&#39;</span>), flags.end());</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06224">CLI::App::_add_flag_internal()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a73b9afbe8a438ab30291d35f1f24c87c_icgraph.svg" width="363" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a242fa1bec3353c591a730efc6307f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242fa1bec3353c591a730efc6307f3ea">&#9670;&nbsp;</a></span>remove_quotes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::remove_quotes </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove quotes at the front and back of a string either '"' or '\'' </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00271">271</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                                                        {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            <span class="keywordflow">if</span> (str.length() &gt; 1 &amp;&amp; (str.front() == <span class="charliteral">&#39;&quot;&#39;</span> || str.front() == <span class="charliteral">&#39;\&#39;&#39;</span>)) {</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                <span class="keywordflow">if</span> (str.front() == str.back()) {</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                    str.pop_back();</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                    str.erase(str.begin(), str.begin() + 1);</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                }</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;            }</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08914">CLI::ConfigBase::from_config()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l08841">generate_parents()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a242fa1bec3353c591a730efc6307f3ea_icgraph.svg" width="791" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5359a7a0e33366a12e15523b100f591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5359a7a0e33366a12e15523b100f591a">&#9670;&nbsp;</a></span>remove_underscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::remove_underscore </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove underscores from a string </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00394">394</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                                                          {</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            str.erase(std::remove(std::begin(str), std::end(str), <span class="charliteral">&#39;_&#39;</span>), std::end(str));</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05029">CLI::Option::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l07331">CLI::App::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00430">find_member()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03643">CLI::ignore_underscore()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a5359a7a0e33366a12e15523b100f591a_icgraph.svg" width="1302" height="274"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af74b520ee1011d38fde77f907ddfea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74b520ee1011d38fde77f907ddfea40">&#9670;&nbsp;</a></span>rjoin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::rjoin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a string in reverse order. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00206">206</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                                                           {</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            std::ostringstream s;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            <span class="keywordflow">for</span> (std::size_t start = 0; start &lt; v.size(); start++) {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                <span class="keywordflow">if</span> (start &gt; 0)</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                    s &lt;&lt; delim;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                s &lt;&lt; v[v.size() - start - 1];</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            }</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            <span class="keywordflow">return</span> s.str();</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed9338ae7c45f34f8240a31325d8d71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9338ae7c45f34f8240a31325d8d71c">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from right of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00237">237</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                                                {</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.rbegin(), str.rend(), [](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                return !std::isspace&lt;char&gt;(ch, std::locale());</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;            });</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            str.erase(it.base(), str.end());</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00255">trim()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aed9338ae7c45f34f8240a31325d8d71c_icgraph.svg" width="742" height="240"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a27306fb661edc7a7017a09a0e9ee7b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27306fb661edc7a7017a09a0e9ee7b18">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from right of string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00246">246</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                                                                         {</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            <span class="keyword">auto</span> it = std::find_if(str.rbegin(), str.rend(), [&amp;filter](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                return filter.find(ch) == std::string::npos;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;            });</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            str.erase(it.base(), str.end());</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03857">split_program_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a27306fb661edc7a7017a09a0e9ee7b18_icgraph.svg" width="480" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa4b4a0a97c9b07110595765887647385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b4a0a97c9b07110595765887647385">&#9670;&nbsp;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V , enable_if_t&lt;!has_find&lt; T, V &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::pair&lt;bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function. </p>
<p>A search function that uses the built in find function. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03324">3324</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03324"></a><span class="lineno"> 3324</span>&#160;                                                                                                             {</div>
<div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03326"></a><span class="lineno"> 3326</span>&#160;            <span class="keyword">auto</span>&amp; setref = <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(set);</div>
<div class="line"><a name="l03327"></a><span class="lineno"> 3327</span>&#160;            <span class="keyword">auto</span> it = std::find_if(std::begin(setref), std::end(setref), [&amp;val](decltype(*std::begin(setref)) v) {</div>
<div class="line"><a name="l03328"></a><span class="lineno"> 3328</span>&#160;                <span class="keywordflow">return</span> (detail::pair_adaptor&lt;element_t&gt;::first(v) == val);</div>
<div class="line"><a name="l03329"></a><span class="lineno"> 3329</span>&#160;            });</div>
<div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160;            <span class="keywordflow">return</span> {(it != std::end(setref)), it};</div>
<div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03264">smart_deref()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03573">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="http__utils_8cpp_source.html#l00178">httputils::ci_contains()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03428">CLI::IsMember::IsMember()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03507">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aa4b4a0a97c9b07110595765887647385_cgraph.svg" width="331" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aa4b4a0a97c9b07110595765887647385_icgraph.svg" width="1952" height="902"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abcb81a667288aa66a4576a06b9322092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb81a667288aa66a4576a06b9322092">&#9670;&nbsp;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; V(V)&gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::pair&lt;bool, decltype(std::begin(<a class="el" href="namespace_c_l_i_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function with a filter function. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03343">3343</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160;                                                                         {</div>
<div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;            <span class="keyword">using</span> element_t = <span class="keyword">typename</span> detail::element_type&lt;T&gt;::type;</div>
<div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;            <span class="comment">// do the potentially faster first search</span></div>
<div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;            <span class="keyword">auto</span> res = <a class="code" href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">search</a>(set, val);</div>
<div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;            <span class="keywordflow">if</span> ((res.first) || (!(filter_function))) {</div>
<div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;                <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;            }</div>
<div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;            <span class="comment">// if we haven&#39;t found it do the longer linear search with all the element translations</span></div>
<div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;            <span class="keyword">auto</span>&amp; setref = <a class="code" href="namespace_c_l_i_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">detail::smart_deref</a>(set);</div>
<div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;            <span class="keyword">auto</span> it = std::find_if(std::begin(setref), std::end(setref), [&amp;](decltype(*std::begin(setref)) v) {</div>
<div class="line"><a name="l03354"></a><span class="lineno"> 3354</span>&#160;                V a{detail::pair_adaptor&lt;element_t&gt;::first(v)};</div>
<div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160;                a = filter_function(a);</div>
<div class="line"><a name="l03356"></a><span class="lineno"> 3356</span>&#160;                <span class="keywordflow">return</span> (a == val);</div>
<div class="line"><a name="l03357"></a><span class="lineno"> 3357</span>&#160;            });</div>
<div class="line"><a name="l03358"></a><span class="lineno"> 3358</span>&#160;            <span class="keywordflow">return</span> {(it != std::end(setref)), it};</div>
<div class="line"><a name="l03359"></a><span class="lineno"> 3359</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_abcb81a667288aa66a4576a06b9322092"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#abcb81a667288aa66a4576a06b9322092">CLI::detail::search</a></div><div class="ttdeci">auto search(const T &amp;set, const V &amp;val, const std::function&lt; V(V)&gt; &amp;filter_function) -&gt; std::pair&lt; bool, decltype(std::begin(detail::smart_deref(set)))&gt;</div><div class="ttdoc">A search function with a filter function.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03343">CLI11.hpp:3343</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01023">CLI::detail::pair_adaptor&lt; T, _ &gt;::first()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03264">smart_deref()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_abcb81a667288aa66a4576a06b9322092_cgraph.svg" width="375" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adcd67b783a1c4441c89f071774ac398b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd67b783a1c4441c89f071774ac398b">&#9670;&nbsp;</a></span>smart_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt;T&gt;::type&amp; CLI::detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03270">3270</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;                                                                   {</div>
<div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;            <span class="keywordflow">return</span> value;</div>
<div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c6cf48feae9d909d52e7b4c346cba29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6cf48feae9d909d52e7b4c346cba29">&#9670;&nbsp;</a></span>smart_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(*value) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03264">3264</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;                                                      {</div>
<div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160;            <span class="keywordflow">return</span> *value;</div>
<div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03573">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03291">generate_map()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03275">generate_set()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03428">CLI::IsMember::IsMember()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03324">search()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03507">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0c6cf48feae9d909d52e7b4c346cba29_icgraph.svg" width="2184" height="902"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9e78d046d8a9c2d6f246bd1e36e57ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78d046d8a9c2d6f246bd1e36e57ec6">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string by a delim. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00154">154</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                                                                          {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            std::vector&lt;std::string&gt; elems;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="comment">// Check to see if empty string, give consistent result</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            <span class="keywordflow">if</span> (s.empty()) {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                elems.emplace_back();</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                std::stringstream ss;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                ss.str(s);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                std::string item;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="keywordflow">while</span> (std::getline(ss, item, delim)) {</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                    elems.push_back(item);</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                }</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            }</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keywordflow">return</span> elems;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05458">CLI::Option::_add_result()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08841">generate_parents()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03125">CLI::detail::IPV4Validator::IPV4Validator()</a>, <a class="el" href="http__utils_8cpp_source.html#l00091">httputils::str_split()</a>, and <a class="el" href="http__utils_8cpp_source.html#l00105">httputils::str_split_last()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9e78d046d8a9c2d6f246bd1e36e57ec6_icgraph.svg" width="1038" height="382"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0de15b0ba0d12c9170d15693477808ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de15b0ba0d12c9170d15693477808ed">&#9670;&nbsp;</a></span>split_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::split_long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02488">2488</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;                                                                                            {</div>
<div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;            <span class="keywordflow">if</span> (current.size() &gt; 2 &amp;&amp; current.substr(0, 2) == <span class="stringliteral">&quot;--&quot;</span> &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(current[2])) {</div>
<div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;                <span class="keyword">auto</span> loc = current.find_first_of(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;                <span class="keywordflow">if</span> (loc != std::string::npos) {</div>
<div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;                    name = current.substr(2, loc - 2);</div>
<div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;                    value = current.substr(loc + 1);</div>
<div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;                    name = current.substr(2);</div>
<div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;                    value = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;                }</div>
<div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;            }</div>
<div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00341">valid_first_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08236">CLI::App::_parse_arg()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l07532">CLI::App::_recognize()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0de15b0ba0d12c9170d15693477808ed_cgraph.svg" width="344" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0de15b0ba0d12c9170d15693477808ed_icgraph.svg" width="580" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abf817a10b92907070c02b752c37aa09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf817a10b92907070c02b752c37aa09d">&#9670;&nbsp;</a></span>split_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split_names </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02520">2520</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;                                                                   {</div>
<div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;            std::vector&lt;std::string&gt; output;</div>
<div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;            std::size_t val;</div>
<div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;            <span class="keywordflow">while</span> ((val = current.find(<span class="stringliteral">&quot;,&quot;</span>)) != std::string::npos) {</div>
<div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;                output.push_back(<a class="code" href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">trim_copy</a>(current.substr(0, val)));</div>
<div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;                current = current.substr(val + 1);</div>
<div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;            }</div>
<div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;            output.push_back(<a class="code" href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">trim_copy</a>(current));</div>
<div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;            <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a09bd3735d1104a453e5376a43140d5a8"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">CLI::detail::trim_copy</a></div><div class="ttdeci">std::string trim_copy(const std::string &amp;str, const std::string &amp;filter)</div><div class="ttdoc">Make a copy of the string and then trim it, any filter string can be used (any char in string is filt...</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00298">CLI11.hpp:298</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00298">trim_copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l02532">get_default_flag_values()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l04421">CLI::Option::Option()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_abf817a10b92907070c02b752c37aa09d_cgraph.svg" width="687" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_abf817a10b92907070c02b752c37aa09d_icgraph.svg" width="546" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a33c9893591d9e9d3d4c9d7282d50b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c9893591d9e9d3d4c9d7282d50b9d2">&#9670;&nbsp;</a></span>split_program_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; CLI::detail::split_program_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>commandline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a program name and command line arguments the string is assumed to contain a file name followed by other arguments the return value contains is a pair with the first argument containing the program name and the second everything else. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l03857">3857</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l03857"></a><span class="lineno"> 3857</span>&#160;                                                                                       {</div>
<div class="line"><a name="l03858"></a><span class="lineno"> 3858</span>&#160;            <span class="comment">// try to determine the programName</span></div>
<div class="line"><a name="l03859"></a><span class="lineno"> 3859</span>&#160;            std::pair&lt;std::string, std::string&gt; vals;</div>
<div class="line"><a name="l03860"></a><span class="lineno"> 3860</span>&#160;            <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(commandline);</div>
<div class="line"><a name="l03861"></a><span class="lineno"> 3861</span>&#160;            <span class="keyword">auto</span> esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><a name="l03862"></a><span class="lineno"> 3862</span>&#160;            <span class="keywordflow">while</span> (<a class="code" href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">detail::check_path</a>(commandline.substr(0, esp).c_str()) != path_type::file) {</div>
<div class="line"><a name="l03863"></a><span class="lineno"> 3863</span>&#160;                esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, esp + 1);</div>
<div class="line"><a name="l03864"></a><span class="lineno"> 3864</span>&#160;                <span class="keywordflow">if</span> (esp == std::string::npos) {</div>
<div class="line"><a name="l03865"></a><span class="lineno"> 3865</span>&#160;                    <span class="comment">// if we have reached the end and haven&#39;t found a valid file just assume the first argument is the</span></div>
<div class="line"><a name="l03866"></a><span class="lineno"> 3866</span>&#160;                    <span class="comment">// program name</span></div>
<div class="line"><a name="l03867"></a><span class="lineno"> 3867</span>&#160;                    <span class="keywordflow">if</span> (commandline[0] == <span class="charliteral">&#39;&quot;&#39;</span> || commandline[0] == <span class="charliteral">&#39;\&#39;&#39;</span> || commandline[0] == <span class="charliteral">&#39;`&#39;</span>) {</div>
<div class="line"><a name="l03868"></a><span class="lineno"> 3868</span>&#160;                        <span class="keywordtype">bool</span> embeddedQuote = <span class="keyword">false</span>;</div>
<div class="line"><a name="l03869"></a><span class="lineno"> 3869</span>&#160;                        <span class="keyword">auto</span> keyChar = commandline[0];</div>
<div class="line"><a name="l03870"></a><span class="lineno"> 3870</span>&#160;                        <span class="keyword">auto</span> end = commandline.find_first_of(keyChar, 1);</div>
<div class="line"><a name="l03871"></a><span class="lineno"> 3871</span>&#160;                        <span class="keywordflow">while</span> ((end != std::string::npos) &amp;&amp; (commandline[end - 1] == <span class="charliteral">&#39;\\&#39;</span>)) { <span class="comment">// deal with escaped quotes</span></div>
<div class="line"><a name="l03872"></a><span class="lineno"> 3872</span>&#160;                            end = commandline.find_first_of(keyChar, end + 1);</div>
<div class="line"><a name="l03873"></a><span class="lineno"> 3873</span>&#160;                            embeddedQuote = <span class="keyword">true</span>;</div>
<div class="line"><a name="l03874"></a><span class="lineno"> 3874</span>&#160;                        }</div>
<div class="line"><a name="l03875"></a><span class="lineno"> 3875</span>&#160;                        <span class="keywordflow">if</span> (end != std::string::npos) {</div>
<div class="line"><a name="l03876"></a><span class="lineno"> 3876</span>&#160;                            vals.first = commandline.substr(1, end - 1);</div>
<div class="line"><a name="l03877"></a><span class="lineno"> 3877</span>&#160;                            esp = end + 1;</div>
<div class="line"><a name="l03878"></a><span class="lineno"> 3878</span>&#160;                            <span class="keywordflow">if</span> (embeddedQuote) {</div>
<div class="line"><a name="l03879"></a><span class="lineno"> 3879</span>&#160;                                vals.first = <a class="code" href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">find_and_replace</a>(vals.first, std::string(<span class="stringliteral">&quot;\\&quot;</span>) + keyChar, std::string(1, keyChar));</div>
<div class="line"><a name="l03880"></a><span class="lineno"> 3880</span>&#160;                            }</div>
<div class="line"><a name="l03881"></a><span class="lineno"> 3881</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l03882"></a><span class="lineno"> 3882</span>&#160;                            esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><a name="l03883"></a><span class="lineno"> 3883</span>&#160;                        }</div>
<div class="line"><a name="l03884"></a><span class="lineno"> 3884</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l03885"></a><span class="lineno"> 3885</span>&#160;                        esp = commandline.find_first_of(<span class="charliteral">&#39; &#39;</span>, 1);</div>
<div class="line"><a name="l03886"></a><span class="lineno"> 3886</span>&#160;                    }</div>
<div class="line"><a name="l03887"></a><span class="lineno"> 3887</span>&#160; </div>
<div class="line"><a name="l03888"></a><span class="lineno"> 3888</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l03889"></a><span class="lineno"> 3889</span>&#160;                }</div>
<div class="line"><a name="l03890"></a><span class="lineno"> 3890</span>&#160;            }</div>
<div class="line"><a name="l03891"></a><span class="lineno"> 3891</span>&#160;            <span class="keywordflow">if</span> (vals.first.empty()) {</div>
<div class="line"><a name="l03892"></a><span class="lineno"> 3892</span>&#160;                vals.first = commandline.substr(0, esp);</div>
<div class="line"><a name="l03893"></a><span class="lineno"> 3893</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a>(vals.first);</div>
<div class="line"><a name="l03894"></a><span class="lineno"> 3894</span>&#160;            }</div>
<div class="line"><a name="l03895"></a><span class="lineno"> 3895</span>&#160; </div>
<div class="line"><a name="l03896"></a><span class="lineno"> 3896</span>&#160;            <span class="comment">// strip the program name</span></div>
<div class="line"><a name="l03897"></a><span class="lineno"> 3897</span>&#160;            vals.second = (esp != std::string::npos) ? commandline.substr(esp + 1) : std::string{};</div>
<div class="line"><a name="l03898"></a><span class="lineno"> 3898</span>&#160;            <a class="code" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a>(vals.second);</div>
<div class="line"><a name="l03899"></a><span class="lineno"> 3899</span>&#160;            <span class="keywordflow">return</span> vals;</div>
<div class="line"><a name="l03900"></a><span class="lineno"> 3900</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a197be0b62b4d4deef0f5cac600a6b759"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">CLI::detail::check_path</a></div><div class="ttdeci">path_type check_path(const char *file) noexcept</div><div class="ttdoc">get the type of the path from a file name</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l03041">CLI11.hpp:3041</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a27306fb661edc7a7017a09a0e9ee7b18"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">CLI::detail::rtrim</a></div><div class="ttdeci">std::string &amp; rtrim(std::string &amp;str, const std::string &amp;filter)</div><div class="ttdoc">Trim anything from right of string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00246">CLI11.hpp:246</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a2cb44de7c57bbb1384f737dc2f04265b"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">CLI::detail::ltrim</a></div><div class="ttdeci">std::string &amp; ltrim(std::string &amp;str, const std::string &amp;filter)</div><div class="ttdoc">Trim anything from left of string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00228">CLI11.hpp:228</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a42ffd53b391fe1eebc540f26c8825692"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">CLI::detail::trim</a></div><div class="ttdeci">std::string &amp; trim(std::string &amp;str, const std::string filter)</div><div class="ttdoc">Trim anything from string.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00260">CLI11.hpp:260</a></div></div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_ab39b1977d7375250cc57d90723cf1554"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">CLI::detail::find_and_replace</a></div><div class="ttdeci">std::string find_and_replace(std::string str, std::string from, std::string to)</div><div class="ttdoc">Find and replace a substring with another substring.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00400">CLI11.hpp:400</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l03041">check_path()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00400">find_and_replace()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00228">ltrim()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00246">rtrim()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00260">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06688">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a33c9893591d9e9d3d4c9d7282d50b9d2_cgraph.svg" width="531" height="282"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a33c9893591d9e9d3d4c9d7282d50b9d2_icgraph.svg" width="306" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1e6f215bcb727ff49f126ac3e1a13e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6f215bcb727ff49f126ac3e1a13e40">&#9670;&nbsp;</a></span>split_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::split_short </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02478">2478</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;                                                                                            {</div>
<div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;            <span class="keywordflow">if</span> (current.size() &gt; 1 &amp;&amp; current[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(current[1])) {</div>
<div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;                name = current.substr(1, 1);</div>
<div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;                rest = current.substr(2);</div>
<div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;            }</div>
<div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00341">valid_first_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08236">CLI::App::_parse_arg()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l07532">CLI::App::_recognize()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a1e6f215bcb727ff49f126ac3e1a13e40_cgraph.svg" width="308" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a1e6f215bcb727ff49f126ac3e1a13e40_icgraph.svg" width="544" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aad6e8a6354d9645d3da614f6734573a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6e8a6354d9645d3da614f6734573a8">&#9670;&nbsp;</a></span>split_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split_up </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'\0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string '"one two" "three"' into 'one two', 'three' Quote characters can be &lsquo; &rsquo; or " </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00470">470</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            <span class="keyword">const</span> std::string delims(<span class="stringliteral">&quot;\&#39;\&quot;`&quot;</span>);</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;            <span class="keyword">auto</span> find_ws = [delimiter](<span class="keywordtype">char</span> ch) {</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                <span class="keywordflow">return</span> (delimiter == <span class="charliteral">&#39;\0&#39;</span>) ? (std::isspace&lt;char&gt;(ch, std::locale()) != 0) : (ch == delimiter);</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;            };</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;            <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(str);</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160; </div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            std::vector&lt;std::string&gt; output;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            <span class="keywordtype">bool</span> embeddedQuote = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            <span class="keywordtype">char</span> keyChar = <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            <span class="keywordflow">while</span> (!str.empty()) {</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                <span class="keywordflow">if</span> (delims.find_first_of(str[0]) != std::string::npos) {</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;                    keyChar = str[0];</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                    <span class="keyword">auto</span> end = str.find_first_of(keyChar, 1);</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                    <span class="keywordflow">while</span> ((end != std::string::npos) &amp;&amp; (str[end - 1] == <span class="charliteral">&#39;\\&#39;</span>)) { <span class="comment">// deal with escaped quotes</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                        end = str.find_first_of(keyChar, end + 1);</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                        embeddedQuote = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                    }</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                    <span class="keywordflow">if</span> (end != std::string::npos) {</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                        output.push_back(str.substr(1, end - 1));</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                        <span class="keywordflow">if</span> (end + 2 &lt; str.size()) {</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                            str = str.substr(end + 2);</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                            str.clear();</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                        }</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160; </div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                        output.push_back(str.substr(1));</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                        str = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                    }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                    <span class="keyword">auto</span> it = std::find_if(std::begin(str), std::end(str), find_ws);</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                    <span class="keywordflow">if</span> (it != std::end(str)) {</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                        std::string value = std::string(str.begin(), it);</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                        output.push_back(value);</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                        str = std::string(it + 1, str.end());</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                        output.push_back(str);</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                        str = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                    }</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                }</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                <span class="comment">// transform any embedded quotes into the regular character</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                <span class="keywordflow">if</span> (embeddedQuote) {</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                    output.back() = <a class="code" href="namespace_c_l_i_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">find_and_replace</a>(output.back(), std::string(<span class="stringliteral">&quot;\\&quot;</span>) + keyChar, std::string(1, keyChar));</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                    embeddedQuote = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                }</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;                <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(str);</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            }</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00400">find_and_replace()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00255">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08914">CLI::ConfigBase::from_config()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l06688">CLI::App::parse()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aad6e8a6354d9645d3da614f6734573a8_cgraph.svg" width="531" height="130"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aad6e8a6354d9645d3da614f6734573a8_icgraph.svg" width="368" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aadbd2b5b93afe2f10427dd6e32639b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbd2b5b93afe2f10427dd6e32639b0c">&#9670;&nbsp;</a></span>split_windows_style()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::split_windows_style </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l02504">2504</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;            <span class="keywordflow">if</span> (current.size() &gt; 1 &amp;&amp; current[0] == <span class="charliteral">&#39;/&#39;</span> &amp;&amp; <a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(current[1])) {</div>
<div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;                <span class="keyword">auto</span> loc = current.find_first_of(<span class="charliteral">&#39;:&#39;</span>);</div>
<div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;                <span class="keywordflow">if</span> (loc != std::string::npos) {</div>
<div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;                    name = current.substr(1, loc - 1);</div>
<div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;                    value = current.substr(loc + 1);</div>
<div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;                    name = current.substr(1);</div>
<div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;                    value = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;                }</div>
<div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;            }</div>
<div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00341">valid_first_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08236">CLI::App::_parse_arg()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l07532">CLI::App::_recognize()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aadbd2b5b93afe2f10427dd6e32639b0c_cgraph.svg" width="311" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_aadbd2b5b93afe2f10427dd6e32639b0c_icgraph.svg" width="547" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af45abf683b881127298aa28b3c4e6cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45abf683b881127298aa28b3c4e6cf5">&#9670;&nbsp;</a></span>to_flag_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t CLI::detail::to_flag_value </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a flag into an integer value typically binary flags. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01763">1763</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;                                                       {</div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string trueString(<span class="stringliteral">&quot;true&quot;</span>);</div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string falseString(<span class="stringliteral">&quot;false&quot;</span>);</div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;            <span class="keywordflow">if</span> (val == trueString) {</div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;                <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;            }</div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;            <span class="keywordflow">if</span> (val == falseString) {</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;                <span class="keywordflow">return</span> -1;</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;            }</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;            val = <a class="code" href="namespace_c_l_i_1_1detail.html#ae83709ec148057ec53df4383645727e9">detail::to_lower</a>(val);</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;            std::int64_t ret;</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;            <span class="keywordflow">if</span> (val.size() == 1) {</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;                <span class="keywordflow">if</span> (val[0] &gt;= <span class="charliteral">&#39;1&#39;</span> &amp;&amp; val[0] &lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;                    <span class="keywordflow">return</span> (<span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(val[0]) - <span class="charliteral">&#39;0&#39;</span>);</div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;                }</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;                <span class="keywordflow">switch</span> (val[0]) {</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:</div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>:</div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>:</div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;-&#39;</span>:</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;                        ret = -1;</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>:</div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;y&#39;</span>:</div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;                    <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>:</div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;                        ret = 1;</div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;                        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;unrecognized character&quot;</span>);</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;                }</div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;                <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;            }</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;            <span class="keywordflow">if</span> (val == trueString || val == <span class="stringliteral">&quot;on&quot;</span> || val == <span class="stringliteral">&quot;yes&quot;</span> || val == <span class="stringliteral">&quot;enable&quot;</span>) {</div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;                ret = 1;</div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val == falseString || val == <span class="stringliteral">&quot;off&quot;</span> || val == <span class="stringliteral">&quot;no&quot;</span> || val == <span class="stringliteral">&quot;disable&quot;</span>) {</div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;                ret = -1;</div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;                ret = std::stoll(val);</div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;            }</div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;            <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00386">to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l05077">CLI::Option::get_flag_value()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af45abf683b881127298aa28b3c4e6cf5_cgraph.svg" width="350" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_af45abf683b881127298aa28b3c4e6cf5_icgraph.svg" width="574" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae83709ec148057ec53df4383645727e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83709ec148057ec53df4383645727e9">&#9670;&nbsp;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a lower case version of a string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00386">386</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                                                 {</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            std::transform(std::begin(str), std::end(str), std::begin(str), [](<span class="keyword">const</span> std::string::value_type&amp; x) {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                <span class="keywordflow">return</span> std::tolower(x, std::locale());</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            });</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            <span class="keywordflow">return</span> str;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05029">CLI::Option::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l07331">CLI::App::check_name()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00430">find_member()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08914">CLI::ConfigBase::from_config()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08841">generate_parents()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03638">CLI::ignore_case()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09282">CLI::Formatter::make_subcommands()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l01763">to_flag_value()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03751">CLI::AsNumberWithUnit::validate_mapping()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ae83709ec148057ec53df4383645727e9_icgraph.svg" width="1315" height="554"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4e5965e3013bad7369e985e2f2fd42f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5965e3013bad7369e985e2f2fd42f4">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a string from the object. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01211">1211</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;                                            {</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;            <span class="keywordflow">return</span> std::string(value);</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c070858740ce15aaecb1c5f04e21a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c070858740ce15aaecb1c5f04e21a09">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (streaming must be supported for that type) </p>
<p>convert a readable container to a string</p>
<p>If conversion is not supported, return an empty string (streaming is not supported for that type) </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01220">1220</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;                                       {</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;            std::stringstream stream;</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;            stream &lt;&lt; value;</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;            <span class="keywordflow">return</span> stream.str();</div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l00829">CLI::ArgumentMismatch::AtLeast()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00832">CLI::ArgumentMismatch::AtMost()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l01252">checked_to_string()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05077">CLI::Option::get_flag_value()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06492">CLI::App::get_subcommand()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06520">CLI::App::get_subcommand_ptr()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09180">CLI::Formatter::make_description()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00794">CLI::RequiredError::Option()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00788">CLI::RequiredError::Subcommand()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00835">CLI::ArgumentMismatch::TypedAtLeast()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l01263">value_string()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9c070858740ce15aaecb1c5f04e21a09_icgraph.svg" width="907" height="760"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0e94052d485636fc9f18c21009026577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e94052d485636fc9f18c21009026577">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(std::forward&lt;T&gt;(value)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (directly forward if this can become a string) </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01203">1203</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;                                                                    {</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;            <span class="keywordflow">return</span> std::forward&lt;T&gt;(value);</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03235">CLI::Bound::Bound()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03573">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05302">CLI::Option::default_val()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03291">generate_map()</a>, <a class="el" href="_event_loop_8cpp_source.html#l00122">core::getTickCounterAsString()</a>, <a class="el" href="web_2http_2client_2_request_8cpp_source.html#l00185">web::http::client::Request::send()</a>, <a class="el" href="web_2http_2server_2_response_8cpp_source.html#l00067">web::http::server::Response::send()</a>, <a class="el" href="express_2_response_8cpp_source.html#l00042">express::Response::sendFile()</a>, <a class="el" href="web_2http_2client_2_request_8cpp_source.html#l00143">web::http::client::Request::sendHeader()</a>, <a class="el" href="web_2http_2server_2_response_8cpp_source.html#l00172">web::http::server::Response::sendHeader()</a>, <a class="el" href="in_2_socket_address_8cpp_source.html#l00128">net::in::SocketAddress::toString()</a>, <a class="el" href="in6_2_socket_address_8cpp_source.html#l00128">net::in6::SocketAddress::toString()</a>, <a class="el" href="l2_2_socket_address_8cpp_source.html#l00078">net::l2::SocketAddress::toString()</a>, and <a class="el" href="rf_2_socket_address_8cpp_source.html#l00078">net::rf::SocketAddress::toString()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a0e94052d485636fc9f18c21009026577_icgraph.svg" width="1570" height="1262"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad394fad44bd6c2a82604abba63224a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad394fad44bd6c2a82604abba63224a92">&#9670;&nbsp;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00255">255</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                                               {</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a>(str));</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00219">ltrim()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00237">rtrim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03680">CLI::AsNumberWithUnit::AsNumberWithUnit()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l08914">CLI::ConfigBase::from_config()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l06688">CLI::App::parse()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l00470">split_up()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00265">trim_copy()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ad394fad44bd6c2a82604abba63224a92_cgraph.svg" width="308" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ad394fad44bd6c2a82604abba63224a92_icgraph.svg" width="567" height="236"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a42ffd53b391fe1eebc540f26c8825692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ffd53b391fe1eebc540f26c8825692">&#9670;&nbsp;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from string. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00260">260</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                                                                       {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a>(<a class="code" href="namespace_c_l_i_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a>(str, filter), filter);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00219">ltrim()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00237">rtrim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03857">split_program_name()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a42ffd53b391fe1eebc540f26c8825692_cgraph.svg" width="308" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a42ffd53b391fe1eebc540f26c8825692_icgraph.svg" width="476" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5c7b00a328b3b2da564794081646c251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7b00a328b3b2da564794081646c251">&#9670;&nbsp;</a></span>trim_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of the string and then trim it. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00265">265</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                                                         {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            std::string s = str;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(s);</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00255">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08914">CLI::ConfigBase::from_config()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a5c7b00a328b3b2da564794081646c251_cgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a5c7b00a328b3b2da564794081646c251_icgraph.svg" width="382" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a09bd3735d1104a453e5376a43140d5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bd3735d1104a453e5376a43140d5a8">&#9670;&nbsp;</a></span>trim_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of the string and then trim it, any filter string can be used (any char in string is filtered) </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00298">298</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                                                                  {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            std::string s = str;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a>(s, filter);</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00255">trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l02520">split_names()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a09bd3735d1104a453e5376a43140d5a8_cgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a09bd3735d1104a453e5376a43140d5a8_icgraph.svg" width="754" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af643ce5d039d1c94f85ca05591501085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643ce5d039d1c94f85ca05591501085">&#9670;&nbsp;</a></span>tuple_type_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;I == <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type CLI::detail::tuple_type_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0 if the index &gt; tuple size </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01361">1361</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;                                                                                                 {</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af5d45f7af2004b701e37af90df4c031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d45f7af2004b701e37af90df4c031b">&#9670;&nbsp;</a></span>type_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; I&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type <a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a>&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + <a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt;T, I + 1&gt;); } template &lt;typename T&gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt;T, 0&gt;)}; }; template &lt;typename T&gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count.html">subtype_count</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value ? <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> : <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value}; }; template &lt;typename T, typename Enable = void&gt; struct type_count_min { static const int value{0}; }; template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value}; }; template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{1}; }; template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt;typename T::value_type&gt;::value}; }; template &lt;typename T, std::size_t I&gt; constexpr typename std::enable_if&lt;I == <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type tuple_type_size_min() { return 0; } template &lt;typename T, std::size_t I&gt; constexpr typename std::enable_if &lt; I&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, int&gt;::type tuple_type_size_min() { return <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + tuple_type_size_min&lt;T, I + 1&gt;); } template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{tuple_type_size_min&lt;T, 0&gt;)}; }; template &lt;typename T&gt; struct <a class="el" href="struct_c_l_i_1_1detail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr int value{<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value ? ((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value &lt; <a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>) ? <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value : 0) : type_count_min&lt;T&gt;::value}; }; template &lt;typename T, typename Enable = void&gt; struct expected_count { static const int value{0}; }; template &lt;typename T&gt; struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{1}; }; template &lt;typename T&gt; struct expected_count&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{<a class="el" href="namespace_c_l_i_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>}; }; template &lt;typename T&gt; struct expected_count&lt;T, typename std::enable_if&lt;!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{expected_count&lt;typename T::value_type&gt;::value}; }; enum class object_category : int { char_value = 1, integral_value = 2, unsigned_integral = 4, enumeration = 6, boolean_value = 8, floating_point = 10, number_constructible = 12, double_constructible = 14, integer_constructible = 16, string_assignable = 23, string_constructible = 24, other = 45, wrapper_value = 50, complex_number = 60, tuple_value = 70, container_value = 80, }; template &lt;typename T, typename Enable = void&gt; struct classify_object { static constexpr object_category value{object_category::other}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, char&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::integral_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, char&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::unsigned_integral}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_same&lt;T, char&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::char_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1is__bool.html">is_bool</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::boolean_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::floating_point}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; std::is_assignable&lt;T&amp;, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::string_assignable}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T&amp;, std::string&gt;::value &amp;&amp; (<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1) &amp;&amp; std::is_constructible&lt;T, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::string_constructible}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::enumeration}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::complex_number}; }; template &lt;typename T&gt; struct uncommon_type { using type = typename std::conditional&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T&amp;, std::string&gt;::value &amp;&amp; !std::is_constructible&lt;T, std::string&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value, std::true_type, std::false_type&gt;::type; static constexpr bool value = type::value; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;(!<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; uncommon_type&lt;T&gt;::value)&gt;::type&gt; { static constexpr object_category value{object_category::wrapper_value}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::number_constructible}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::integer_constructible}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::double_constructible}; }; template &lt;typename T&gt; struct classify_object&lt; T, typename std::enable_if&lt;<a class="el" href="class_c_l_i_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; ((<a class="el" href="struct_c_l_i_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value &gt;= 2 &amp;&amp; !<a class="el" href="struct_c_l_i_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value) || (uncommon_type&lt;T&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, double&gt;::value &amp;&amp; !<a class="el" href="class_c_l_i_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, int&gt;::value))&gt;::type&gt; { static constexpr object_category value{object_category::tuple_value}; }; template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="struct_c_l_i_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::container_value}; }; template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::char_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;CHAR&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::integral_value || classify_object&lt;T&gt;::value == object_category::integer_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;INT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::unsigned_integral, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;UINT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::floating_point || classify_object&lt;T&gt;::value == object_category::number_constructible || classify_object&lt;T&gt;::value == object_category::double_constructible, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;FLOAT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::enumeration, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;ENUM&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::boolean_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;BOOLEAN&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::complex_number, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;COMPLEX&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value &gt;= object_category::string_assignable &amp;&amp; classify_object&lt;T&gt;::value &lt;= object_category::other, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; constexpr const char* type_name() { return &quot;TEXT&quot;; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value &gt;= 2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; std::string type_name(); template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::container_value || classify_object&lt;T&gt;::value == object_category::wrapper_value, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; std::string type_name(); template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value == 1, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespace_c_l_i_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt; inline std::string type_name() { return type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;0, T&gt;::type&gt;::type&gt;); } template &lt;typename T, std::size_t I&gt; inline typename std::enable_if&lt;I == <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, std::string&gt;::type tuple_name() { return std::string{}; } template &lt;typename T, std::size_t I&gt; inline typename std::enable_if&lt;(I &lt; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value), std::string&gt;::type tuple_name() { std::string str = std::string(type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::type&gt;)) + ',' + tuple_name&lt;T, I + 1&gt;); <a class="el" href="instrumentation_8cpp.html#ac37cec2090666222861a77657149ef94">if</a> (str.back() == ',') str.pop_back(); return str; } template &lt;typename T, <a class="el" href="namespace_c_l_i.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="struct_c_l_i_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value &gt;= 2, <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; &gt; std::string CLI::detail::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively generate the tuple type name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01721">1721</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;                                     {</div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;            <span class="keyword">auto</span> tname = std::string(1, <span class="charliteral">&#39;[&#39;</span>) + tuple_name&lt;T, 0&gt;();</div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;            tname.push_back(<span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;            <span class="keywordflow">return</span> tname;</div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a397d777acde370a61fdfc1022a97508b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397d777acde370a61fdfc1022a97508b">&#9670;&nbsp;</a></span>type_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type name for a type that has a value_type member </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01732">1732</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;                                     {</div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;            <span class="keywordflow">return</span> type_name&lt;typename T::value_type&gt;();</div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac75f9ea4aa9649b9b3890bdcbc64b75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75f9ea4aa9649b9b3890bdcbc64b75a">&#9670;&nbsp;</a></span>valid_alias_name_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_alias_name_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify an app name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00367">367</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                                                                  {</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;            <span class="keyword">static</span> <span class="keyword">const</span> std::string badChars(std::string(<span class="stringliteral">&quot;\n&quot;</span>) + <span class="charliteral">&#39;\0&#39;</span>);</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;            <span class="keywordflow">return</span> (str.find_first_of(badChars) == std::string::npos);</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06408">CLI::App::add_option_group()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l05824">CLI::App::alias()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l04145">CLI::OptionBase&lt; CRTP &gt;::group()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_ac75f9ea4aa9649b9b3890bdcbc64b75a_icgraph.svg" width="378" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3a05d1129df69e88135e178137b1fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a05d1129df69e88135e178137b1fd89">&#9670;&nbsp;</a></span>valid_first_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_first_char </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify the first character of an option</p><ul>
<li>is a trigger character, ! has special meaning and new lines would just be annoying to deal with </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00341">341</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                   {</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            <span class="keywordflow">return</span> ((c != <span class="charliteral">&#39;-&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39;!&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39; &#39;</span>) &amp;&amp; c != <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06425">CLI::App::add_subcommand()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02560">get_names()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02488">split_long()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02478">split_short()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l02504">split_windows_style()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00355">valid_name_string()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a3a05d1129df69e88135e178137b1fd89_icgraph.svg" width="1107" height="648"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a841371d5dbb0a52f453de4cc1d00cc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841371d5dbb0a52f453de4cc1d00cc51">&#9670;&nbsp;</a></span>valid_later_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_later_char </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify following characters of an option. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00347">347</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                                   {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;            <span class="comment">// = and : are value separators, { has special meaning for option defaults,</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            <span class="comment">// and \n would just be annoying to deal with in many places allowing space here has too much potential for</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            <span class="comment">// inadvertent entry errors and bugs</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            <span class="keywordflow">return</span> ((c != <span class="charliteral">&#39;=&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39;:&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39;{&#39;</span>) &amp;&amp; (c != <span class="charliteral">&#39; &#39;</span>) &amp;&amp; c != <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06425">CLI::App::add_subcommand()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00355">valid_name_string()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a841371d5dbb0a52f453de4cc1d00cc51_icgraph.svg" width="1075" height="532"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4274628d24f9e3fbc719284f1db263b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274628d24f9e3fbc719284f1db263b8">&#9670;&nbsp;</a></span>valid_name_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLI::detail::valid_name_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify an option/subcommand name. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00355">355</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                                            {</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            <span class="keywordflow">if</span> (str.empty() || !<a class="code" href="namespace_c_l_i_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a>(str[0])) {</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            }</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;            <span class="keyword">auto</span> e = str.end();</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> c = str.begin() + 1; c != e; ++c)</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">valid_later_char</a>(*c))</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        }</div>
<div class="ttc" id="anamespace_c_l_i_1_1detail_html_a841371d5dbb0a52f453de4cc1d00cc51"><div class="ttname"><a href="namespace_c_l_i_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">CLI::detail::valid_later_char</a></div><div class="ttdeci">bool valid_later_char(T c)</div><div class="ttdoc">Verify following characters of an option.</div><div class="ttdef"><b>Definition:</b> <a href="_c_l_i11_8hpp_source.html#l00347">CLI11.hpp:347</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l00341">valid_first_char()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l00347">valid_later_char()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l06425">CLI::App::add_subcommand()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l02560">get_names()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a4274628d24f9e3fbc719284f1db263b8_cgraph.svg" width="312" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a4274628d24f9e3fbc719284f1db263b8_icgraph.svg" width="900" height="532"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9a74f119a795b25c40db74ffa21d3c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74f119a795b25c40db74ffa21d3c2d">&#9670;&nbsp;</a></span>value_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a string as a convertible value for arithmetic types </p>
<p>get a string as a convertible value for enumerations </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01263">1263</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;                                               {</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">std::to_string</a>(value);</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01220">to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l03573">CLI::CheckedTransformer::CheckedTransformer()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l03428">CLI::IsMember::IsMember()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l03507">CLI::Transformer::Transformer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9a74f119a795b25c40db74ffa21d3c2d_cgraph.svg" width="342" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a9a74f119a795b25c40db74ffa21d3c2d_icgraph.svg" width="406" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a130e048f492ea4619246e2f4cabaf4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130e048f492ea4619246e2f4cabaf4ac">&#9670;&nbsp;</a></span>value_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespace_c_l_i_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(value)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for other types just use the regular to_string function </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l01273">1273</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;                                                                        {</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespace_c_l_i_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">to_string</a>(value);</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_c_l_i11_8hpp_source.html#l01220">to_string()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_c_l_i_1_1detail_a130e048f492ea4619246e2f4cabaf4ac_cgraph.svg" width="342" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a01c35a876e2917ffdc1ee618e0c06619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c35a876e2917ffdc1ee618e0c06619">&#9670;&nbsp;</a></span>dummy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_c_l_i_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a> CLI::detail::dummy = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An instance to use in EnableIf. </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00926">926</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>

</div>
</div>
<a id="a99abe3824b1f1bea457ad0ae635f5c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99abe3824b1f1bea457ad0ae635f5c51">&#9670;&nbsp;</a></span>expected_max_vector_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int CLI::detail::expected_max_vector_size {1 &lt;&lt; 29}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>a constant defining an expected max vector size defined to be a big number that could be multiplied by 4 and not produce overflow for some expected uses </p>

<p class="definition">Definition at line <a class="el" href="_c_l_i11_8hpp_source.html#l00151">151</a> of file <a class="el" href="_c_l_i11_8hpp_source.html">CLI11.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_c_l_i11_8hpp_source.html#l08236">CLI::App::_parse_arg()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l07434">CLI::App::_validate()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04461">CLI::Option::expected()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04866">CLI::Option::get_items_expected_max()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09357">CLI::Formatter::make_option_opts()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l09396">CLI::Formatter::make_option_usage()</a>, <a class="el" href="_c_l_i11_8hpp_source.html#l04753">CLI::Option::multi_option_policy()</a>, and <a class="el" href="_c_l_i11_8hpp_source.html#l05231">CLI::Option::type_size()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_c_l_i.html">CLI</a></li><li class="navelem"><a class="el" href="namespace_c_l_i_1_1detail.html">detail</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
